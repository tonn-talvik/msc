\documentclass[a4paper,12pt]{article}
\usepackage[lmargin=30mm,rmargin=30mm,tmargin=25mm,bmargin=25mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{newtxtext} 

\usepackage{textcomp}
\usepackage{fdsymbol}
\usepackage{stmaryrd}
\usepackage{underscore}


\usepackage{newunicodechar}
\newunicodechar{Γ}{$\Gamma$}
\newunicodechar{ε}{$\epsilon$}
\newunicodechar{λ}{$\lambda$}
\newunicodechar{ρ}{$\rho$}
\newunicodechar{σ}{$\sigma$}
\newunicodechar{τ}{$\tau$}
\newunicodechar{∷}{$\Colon$} % requires fdsymbol
%\newunicodechar{∷}{$::$}
\newunicodechar{●}{$\smblkcircle$}
%\newunicodechar{→}{$\rightarrow$} % not needed
\newunicodechar{⇒}{$\Rightarrow$}
\newunicodechar{⟹}{$\Longrightarrow$} % unused
%\newunicodechar{⊹}{$\hermitmatrix$} % requires stix
%\newunicodechar{⊹}{$+$}
\newunicodechar{⊹}{$\Diamond$}
\newunicodechar{⟦}{$\llbracket$}
\newunicodechar{⟧}{$\rrbracket$}
\newunicodechar{⟪}{$\langle\!\langle$}
\newunicodechar{⟫}{$\rangle\!\rangle$}
\newunicodechar{⟨}{$\langle$}
\newunicodechar{⟩}{$\rangle$}
%\newunicodechar{·}{$\cdot$} % not needed
\newunicodechar{⊔}{$\sqcup$}
\newunicodechar{⊓}{$\sqcap$}
\newunicodechar{∈}{$\in$}
%\newunicodechar{¬}{$\neg$} % not needed
\newunicodechar{≡}{$\equiv$}
\newunicodechar{≢}{$\neq$}
\newunicodechar{≤}{$\leq$}
\newunicodechar{≰}{$\nleq$}
\newunicodechar{⊑}{$\sqsubseteq$}
\newunicodechar{ℕ}{$\mathbb{N}$}
\newunicodechar{∘}{$\circ$}
\newunicodechar{₁}{\textsubscript{1}}
\newunicodechar{₂}{\textsubscript{2}}
\newunicodechar{₃}{\textsubscript{3}}
\newunicodechar{η}{$\eta$}
\newunicodechar{⊤}{$\top$}

\usepackage[estonian]{babel}
%\usepackage[none]{hyphenat}


\usepackage{fancyhdr}
\fancypagestyle{FirstPage}{\fancyhf{}\renewcommand{\headrulewidth}{0pt}\fancyfoot[C]{Tallinn 2017}}

\addto\captionsestonian{
  \renewcommand*\contentsname{\centering Sisukord}
  \renewcommand*\listfigurename{\centering Jooniste loetelu}
  \renewcommand*\refname{Kasutatud kirjandus}
}

\usepackage{hyperref}

\usepackage[figure,table]{totalcount}

%\linespread{1.4}
%\renewcommand{\baselinestretch}{1.5}

\setlength{\parindent}{0pt}
\setlength{\parskip}{12pt}

\usepackage{titlesec}
% http://tex.stackexchange.com/questions/299969/titlesec-loss-of-section-numbering-with-the-new-update-2016-03-15
\usepackage{etoolbox}
\makeatletter
\patchcmd{\ttlh@hang}{\parindent\z@}{\parindent\z@\leavevmode}{}{}
\patchcmd{\ttlh@hang}{\noindent}{}{}{}
\makeatother
\titlespacing*{\section}{0pt}{60pt}{18pt}
\titlespacing*{\subsection}{0pt}{24pt}{12pt}
\titlespacing*{\subsubsection}{0pt}{12pt}{12pt}

\usepackage{float}
%\floatstyle{boxed} 
%\restylefloat{figure}

\usepackage{fancyvrb}
\fvset{fontsize=\small}
% https://tex.stackexchange.com/questions/2651/should-i-use-center-or-centering-for-figures-and-tables
\makeatletter
\g@addto@macro\@floatboxreset\centering
\makeatother

%\usepackage{flafter} % this is required by TTU template, but makes figures hard to follow.. sometimes

\usepackage{tikz}
\usepackage[nounderscore]{syntax}
\setlength{\grammarindent}{3em}
\let\syntleft\relax
\let\syntright\relax
\usepackage{changepage}

\renewcommand{\labelitemi}{$\smblksquare$}

\usepackage{setspace}

\begin{document}
\onehalfspacing

\iffalse
\begin{BVerbatim}
λ ⟦ ⟧ ⟪ ⟫ ⟨ ⟩ · ⊹ ∷ ⊔ ⊓ Γ ρ ε σ τ η ∈ ¬ ≡ ≢ ≤ ≰ ⊑ ● → ⇒ ⟹ _ ℕ 
∘ ₁ ₂ ₃ ⊤
\end{BVerbatim}
\fi
% ------------------------------------------------------------
  \begin{center}
    \uppercase{Tallinna Tehnikaülikool}\\
    Infotehnoloogia teaduskond\\
    Tarkvarateaduse instituut\\
    \vfill
    
    Tõnn Talvik 132619IAPM
    \vskip 3em 
    \LARGE\uppercase{efektianalüüsidel põhinevate programmiteisenduste sertifitseerimine}\\
    \normalsize\vskip 4em 
    Magistritöö\\
    \vskip 4em    
  \end{center}
  
  \begin{flushright}
    \begin{tabular}{ r l }
      Juhendaja:& Tarmo Uustalu\\
      & Professor \\
    \end{tabular}
    \vfill
  \end{flushright}
  
  \thispagestyle{FirstPage}
  \clearpage\vspace*{0pt}
  \setcounter{page}{2}
% ------------------------------------------------------------

\section*{\centering Autorideklaratsioon}

Kinnitan, et olen koostanud antud lõputöö iseseisvalt ning seda ei ole kellegi teise poolt varem kaitsmisele esitatud. Kõik töö koostamisel kasutatud teiste autorite tööd, olulised seisukohad, kirjandusallikatest ja mujalt pärinevad andmed on töös viidatud.

Autor: Tõnn Talvik

8. mai 2017

\clearpage\vspace*{0pt}

\section*{\centering Annotatsioon}

Tüübi- ja efektisüsteemid võimaldavad programmide dünaamilist käitumist analüüsida staatiliste tehnikatega. Analüüsi tulemust saab kasutada näiteks programmi optimeerimiseks.

Selle töö eesmärgiks on luua sõltuvate tüüpidega programmeerimiskeeles Agda idee tõestuse (\emph{proof-of-concept}) raamistu efektide analüüsiks ja nendel põhinevateks programmiteisendusteks.

Töös vaadeldakse esimese näitekeelena tüübitud lambdaarvutust, mida on laiendatud eranditega.
Keele termidele tuletatakse tüübid ning hinnatakse nende võimalikku efekti.
Viimaste võrdlemiseks näidatakse, et hinnangud rahuldavad gradeeritud monaadi omadusi.
Defineeritakse keele semantika ning tuuakse mõned programmilihtsustused tõestades, et need teisendused ei muuda programmi semantilist interpretatsiooni.

Teise näitena kasutatakse mittedeterministlikku keelt.
Efektina hinnatakse programmi võimalike tulemuste arvu.
Defineeritakse vastav gradeeritud monaad ja viiakse läbi tüübi- ja efektituletus.
Näitekeelele antakse semantika ning tuuakse programmiteisenduste näited, ühtlasi tõestades viimaste korrektsust.


Lõputöö on kirjutatud eesti keeles ning sisaldab teksti 39 leheküljel, 4 peatükki, \totalfigures~joonist.
\clearpage\vspace*{0pt}

\section*{\centering Abstract\\
Certification of effect-analysis based program~transformations}

Type-and-effect systems are used to statically analyze program dynamic behaviour.
This allows to perform certain program optimizations.

Functional languages distinguish between value types and computation types.
Monads are used to reason about the latter.

Recent research marries monadic computations and effect systems.
A systematic approach has been given using graded monads, which employs preordered monoids.

The goal of this thesis is to give a proof-of-concept framework for effect-analysis based program transformations.
The work is carried out in a dependently typed functional programming language called Agda.
Such expressive type system allows to provide a proof of program's certification as it is written.
Also, Agda itself is an experimental language and such task has not been tried earlier in this language.

The first example language considered is a typed lambda calculus extended with exceptions.
The starting point is raw terms for which types and effects can be inferred.
Computation types are defined using a graded monad specifically adapted to capture exception effects.
The language semantics is given for refined terms.
Structural transformations, i.e. weakening and contraction, are described next.
Using those, a few example program optimizations, e.g. dead computation and duplicate computation removal, are defined.
These transformations are proved to be correct using Agda as metalanguage.

The second example considers a language which supports non-deterministic choice.
Again, starting from raw terms, their types and effects can be inferred.
The type of upper bounded vectors is defined to define the semantics of the non-deterministic language.
A suitable graded monad is also defined.
Proven optimizing transformations include failed computation and duplicate computation removal.
Since the base language is the same as for exceptions, much of the framework developed for exceptions can be reused.

The thesis is in Estonian and contains 39 pages of text, 4 chapters, \totalfigures~figures.
\clearpage\vspace*{0pt}

\vspace*{60pt}
\begingroup
\addtocontents{toc}{\protect\setstretch{0}}
\def\addvspace#1{}
\tableofcontents
\endgroup

\clearpage\vspace*{0pt}

\addtocontents{lof}{\protect\setstretch{0}}
\listoffigures

\clearpage\vspace*{0pt}

\section{Sissejuhatus}

\subsection{Taust}
Tüübisüsteem võimaldab vältida programmides teatud käitusvigu.
Efektisüsteemi võib vaadelda tüübisüsteemi edasiarendusena, kus lisaks tüüpidele on programm annoteeritud täiendava informatsiooniga, mis kirjeldab programmi käitumist ehk tema efekti käitusfaasis.

Efektisüsteeme on edukalt kasutatud avaldiste rehkendamise ajastamiseks paralleelarvutamisel, kus efektid piiravad arvutuste võimalikku skoopi \cite{Lucassen1988}.
Lihtne efektisüsteem on kasutusel ka Javas, kus meetodid on sildistatud eranditega, mis võivad tekkida vastava meetodi käitusel. 

Staatilise programmianalüüsiga saab hinnata arvutuste võimalikke efekte.
See võimaldab mh viia läbi optimeerivaid programmiteisendusi.
Näiteks saab jälgida, milliseid mälupesasid loetakse ja kirjutatakse, ning selle teadmise alusel eemaldada ``surnud'' (\emph{dead computation}) või liiased arvutused (\emph{duplicated computation}) \cite{Benton2006}.

Klassikaliselt kasutatakse funktsionaalprogrammeerimises mittepuhaste arvutuse tüüpimiseks monaade, st tüübitud on ka arvutused, mitte ainult väärtused.
See lubab arutleda erinevate arvutuste üle nagu näiteks mittedeterminism, erandid, olek jne, mis ei ole võimalik tavalises lambdaarvutuses \cite{Moggi1989}.

Efektisüsteeme saab kohandada ka monaadide jaoks \cite{Wadler1998}.
Süstemaatiline lähenemine monaadide ja efektide kokkupanekuks põhineb parameetrilistel efekti monaadidel ehk gradeeritud monaadidel, mis kasutavad eeljärjestatud monoidi efektide võrdlemiseks \cite{Katsumata2014}.

\subsection{Ülesande püstitus}
% https://courses.cs.ttu.ee/pages/Problem_Statement

% Sissejuhatuses tutvustab autor töö teemat, töö eesmärke, lahendatavat probleemistikku,
% andes samuti ülevaate töö ülesehitusest. Sissejuhatuses kirjeldatakse ka töö
% lähtetingimused, alamülesanded ja vajadusel ka täiendavad nõuded (vt jaotist 2.4 ).

% Lõputöös peab sisalduma selge lõpetaja poolt lahendatava ülesande püstitus.

% Magistritöös esitatakse lahendatava ülesande püstitus töö sissejuhatuses, kattes järgmised punktid:
% - töös lahendatavad küsimused ja lähtetingimused,
% - eritingimused, mida on rakendatud ülesande lahendamisel/ülesande püstitamisel.

% Rigor
Agda on sõltuvate tüüpidega funktsionaalne programmeerimiskeel ja interaktiivne tõestusassistent,
mis põhineb intuitsionistlikul tüübiteoorial.
Selles kirjutatud programm on tõlgendatav ja automaatselt kontrollitav kui matemaatiline tõestus.

% Goal
Selle töö eesmärgiks on realiseerida programmeerimiskeeles Agda idee tõendamise (\emph{proof-of-concept}) 
raamistu efektide analüüsiks ja nendele põhinevateks programmiteisendusteks.
Samas raamistus peab saama näidata, et need teisendused on korrektsed.

Agda on eksperimentaalne keel ja sedalaadi ülesande realisatsioon selles keeles on uudne.
Uurimuse käigus tahame teada, kas niisugune töö on teostatav mõistliku vaevaga, kui õppimisele kuluv aeg maha arvata.

Teoreetilisel tasemel on uudne, et efektide analüüsid ja optimisatsioonid toimivad keele juures, mis toetab andmetüüpe, milleks antud töös on naturaalarvud lihtsaima näitena.

\subsection{Ülevaade tööst}
Teises peatükis realiseeritakse näitekeel, mille efektiks on erandid.
Järgmiseks defineeritakse selliste efektide hindamine.
Seejärel arendatakse näitekeelele tüübisüsteem, mille käigus rafineeritakse keelt lisades selle arvutustele efektid ja tüübid.
Edasi antakse rafineeritud keele semantika ning tuuakse mõningased programmiteisendused, näidates, et semantiliselt on algne ja teisendatud programm ekvivalentsed.

Kolmandas peatükis tuuakse efektianalüüs ja optimeerimise näited mittedeterminismi toetava keele kohta, kasutades ära teises peatükis arendatud raamistut.

% Reproducibility
Töö käigus valminud lähtekood on tulemuste reprodutseerimiseks allalaetav aadressilt \url{https://github.com/tonn-talvik/msc}.
Lähtekoodi kompileerimiseks on kasutatud Agda versiooni 2.5.1.1 koos standardteegi versiooniga 0.12.
Mainitud tarkvarapaketid on tasuta installeeritavad Ubuntu 16.04 LTS või teistest varamutest.

\clearpage\vspace*{0pt}

\section{Erandid}\label{sec:exc}

Selles töös vaadeldavaks baaskeeleks on tüübitud lambdaarvutus koos tõeväärtuste, naturaalarvude ja paaridega.
Selles peatükis vaadeldakse keele laiendust eranditega.

Keele efekt seisneb selles, et arvutus kas õnnestub, mille korral tagastatakse väärtus, või ebaõnnestub, mille korral väärtust ei teki.
Staatilise analüüsiga saab iga arvutuse efekti hinnata järgnevalt: kindel õnnestumine, kindel ebaõnnestumine või staatiliselt teadmata, kas arvutus õnnestub või mitte.
Edaspidi öeldakse efekti hinnangu kohta ka lihtsalt efekt.

Järgnevates alapeatükkides defineeritakse selline keel Agdas,
konstrueeritakse tüübituletus koos efektianalüüsiga,
määratletakse hästi tüübitud avaldiste semantika
ning tuuakse mõned optimeerivate programmiteisenduste näited.
Ühtlasi näidatakse teisenduste korrektsust.

\subsection{Eranditega keel}\label{ssec:exc.raw}

Näitekeele grammatika saab esitada Backus-Naur kujul (BNF) järgnevalt, kus {\tt t} on tüübid, {\tt v} on väärtused ja {\tt c} on arvutused:
\begin{adjustwidth}{1em}{0pt}
\begin{grammar}\tt
<t> ::= nat | bool | t ● t | t ⇒ $e$ / t \hfill ($e \in$ E)
  
<v> ::= TT | FF | ZZ | SS v | ⟨ v , v ⟩ | FST v | SND v
    \alt VAR $n$ | LAM t c \hfill ($n \in \mathbb N$)
  
<c> ::= VAL v | FAIL t | TRY c WITH c
    \alt IF v THEN c ELSE c | v \$ v | PREC v c c | LET c IN c
\end{grammar}
\end{adjustwidth}
Agdas vastastikku defineeritud väärtus- ja arvutustüübid on toodud joonisel~\ref{fig:exc.types}.
Lubatud väärtustüübid {\tt VType} on naturaalarvud, tõeväärtused, teiste väärtustüüpide korrutised ja tüübitud lambdaarvutused.
Arvutustüüpideks on efektiga {\tt E} annoteeritud väärtustüübid. Efekt {\tt E} on defineeritud alapeatükis~\ref{sssec:exc.exc}.
\begin{figure}
  \begin{BVerbatim}
mutual
  data VType : Set where
    nat : VType
    bool : VType
    _●_ : VType → VType → VType
    _⇒_ : VType → CType → VType

  data CType : Set where
    _/_ : E → VType → CType
  \end{BVerbatim}
  \caption{Näitekeele tüübid.}
  \label{fig:exc.types}
\end{figure}


Vastastikku defineeritud väärtus- ja arvutustermid on toodud joonisel~\ref{fig:exc.raw}.
% pragmatics
Termide konstruktorite nimetamisel on kasutatud suurtähti vältimaks võimalikke nimekonflikte Agda standardfunktsioonidega.
Järgnevalt on selgitatud väärtustermi {\tt vTerm} konstruktorite tähendust.
\begin{itemize}
\item {\tt TT} ja {\tt FF} koostavad vastavalt tõeväärtused tõene ja väär.
\item {\tt ZZ} koostab naturaalarvu 0 ja konstruktor {\tt SS} oma argumendist järgneva naturaalarvu.
\item {\tt ⟨_,_⟩} koostab oma argumentide paari.
\item {\tt FST} ja {\tt SND} koostavad vastavalt argumendina antud korrutise esimese ja teise projektsiooni.
\item {\tt VAR} koostab de~Bruijn'i indeksiga määratud muutuja. Iga selline indeks on naturaalarv, mis näitab seestpoolt mitmendale sidumisele antud muutuja viitab. Antud töös loendatakse sidumisi alates nullist.
\item {\tt LAM} on funktsiooniabstraktsiooni konstruktor, seejuures on funktsiooni parameetri väärtustüüp eksplitsiitselt annoteeritud. Funktsiooni kehaks on arvutusterm üle täiendava muutujaga laiendatud skoobi. St lambda seob funktsiooni kehas funktsiooni parameetrile vastava muutuja.
\end{itemize}
\begin{figure}
  \begin{BVerbatim}
mutual
  data vTerm : Set where
    TT FF : vTerm
    ZZ : vTerm
    SS : vTerm → vTerm
    ⟨_,_⟩ : vTerm → vTerm → vTerm
    FST SND : vTerm → vTerm
    VAR : ℕ → vTerm
    LAM : VType → cTerm → vTerm

  data cTerm : Set where
    VAL : vTerm → cTerm
    FAIL : VType → cTerm
    TRY_WITH_ : cTerm → cTerm → cTerm
    IF_THEN_ELSE_ : vTerm → cTerm → cTerm → cTerm
    _$_ : vTerm → vTerm → cTerm
    PREC : vTerm → cTerm → cTerm → cTerm
    LET_IN_ : cTerm → cTerm → cTerm
  \end{BVerbatim}
  \caption{Eranditega keele väärtus- ja arvutustermid.}
  \label{fig:exc.raw}
\end{figure}

Järgnevalt on selgitatud arvutustermi {\tt cTerm} konstruktorite (jn~\ref{fig:exc.raw}) tähendust ja vastavas arvutuses kätketud efekti.
\begin{itemize}
\item {\tt VAL} tähistab õnnestunud arvutust, seejuures arvutuse tulemuseks on väärtustermiga antud konstruktori argument.
\item {\tt FAIL} tähistab arvutuse, mille väärtustüüp on eksplitsiitselt annoteeritud, ebaõnnestumist.
\item {\tt TRY_WITH_} on erandikäsitlejaga arvutus: kogu arvutuse tulemuseks on esimese argumendina antud termi arvutus, kui see õnnestub, vastasel korral aga teise argumendina antud termi arvutus.
\item {\tt IF_THEN_ELSE_} on valikuline arvutus: vastavalt väärtustermi tõeväärtusele on tulemuseks kas esimese (tõene haru) või teise (väär haru) arvutustermiga antud arvutus.
\item {\tt _\$_} on esimese väärtustermiga antud funktsiooni rakendamine teise väärtustermiga antud väärtusele, kusjuures rakendamise efektiks on funktsiooni kehas peituv efekt.
\item {\tt PREC} on primitiivne rekursioon, mille korduste arv on määratud väärtustermiga. Esimene arvutusterm vastab rekursiooni baasile ja teine sammule, kusjuures sammuks on akumulaatori ja sammuloenduri parameetritega funktsioon. Kogu arvutuse efekt vastab kõigi osaarvutuste järjestikku sooritamisele.
\item {\tt LET_IN_} lisab esimese arvutustermiga antud väärtuse teise arvutustermi kontekstis esimeseks muutujaks. Arvutuse efekt vastab osaarvutuste järjestikku sooritamisele.
\end{itemize}

\begin{figure}
  \begin{BVerbatim}
ADD : vTerm
ADD = LAM nat
          (VAL (LAM nat
                    (PREC (VAR 0)
                          (VAL (VAR 1))
                          (VAL (SS (VAR 0))))))

ADD-3-and-4 : cTerm
ADD-3-and-4 = LET ADD $ (SS (SS (SS ZZ)))
              IN VAR 0 $ (SS (SS (SS (SS ZZ))))

BAD-ONE : cTerm
BAD-ONE = ZZ $ TT
  \end{BVerbatim}
  \caption{Näidisavaldised eranditega keeles.}
  \label{fig:exc.raw.ex1}
\end{figure}

Joonisel~\ref{fig:exc.raw.ex1} on toodud kahe naturaalarvu liitmise funktsioon väärtustermina {\tt ADD}
ning naturaalarvude 3 ja 4 liitmine arvutustermina {\tt ADD-3-and-4}.
Lisaks on toodud näide arvutustermist {\tt BAD-ONE}, mida annab konstrueerida,
kuid mis ei oma sisu: naturaalarvu null ei saa rakendada tõeväärtusele tõene.
Sellised halvasti tüübitud termid tuvastatakse tüübituletusega (alaptk~\ref{ssec:exc.inference}).
Harilikus tüübitud lambdaarvutuses, kus de~Bruijn'i indeksite asemel kasutatakse nimesid, saab need termid esitada järgnevalt:
\begin{equation*}
\begin{split}
  \text{ADD} &:= \lambda x^\mathbb{N}.\text{val}~(\lambda y^\mathbb{N}.\text{prec}~y~ (\text{val}~x)~((acc,i).\text{val}~(\text{succ}~acc)))\\
  \text{ADD-3-and-4} &:= \text{let}~f=\text{ADD}~3~\text{in}~f~4\\
  \text{BAD-ONE} &:= 0~\text{true}
\end{split}
\end{equation*}


\subsection{Erandite gradeering}\label{ssec:exc.grading}

Selles alapeatükis defineeritakse erandite efekti hinnangute hulk, operatsioonid hinnangutel ja hinnangute omavaheline järjestus.
Sellega võimaldatakse arvutustüüpide alamtüüpimine.
Ühtlasi näidatakse, et selline hindamine rahuldab eeljärjestatud monoidi ja gradeeritud monaadi omadusi,
millele tuginevad semantika (alaptk~\ref{ssec:exc.semantics}) ja optimisatsioonid (alaptk~\ref{ssec:exc.optimizations}). 

\subsubsection{Erandite efektid}\label{sssec:exc.exc}

Erandite efektide tüüp {\tt Exc} on toodud joonisel~\ref{fig:exc.exc}:
konstruktor {\tt err} vastab arvutuse ebaõnnestumisele,
konstruktor {\tt ok} arvutuse õnnestumisele ja konstruktor {\tt errok} arvutusele,
mille kohta pole teada, kas see õnnestub või mitte.

\begin{figure}
  \begin{BVerbatim}
data Exc : Set where
  err : Exc
  ok : Exc
  errok : Exc

_·_ : Exc → Exc → Exc
ok · e = e
err · e = err
errok · err = err
errok · ok = errok
errok · errok = errok

_⊹_ : Exc → Exc → Exc
err ⊹ e' = e'
ok ⊹ _ = ok
errok ⊹ ok = ok
errok ⊹ _ = errok
  \end{BVerbatim}
  \caption{Erandite efektid ja operatsioonid nendel.}
  \label{fig:exc.exc}
\end{figure}

Efektide korrutamise tehe {\tt _·_} (jn~\ref{fig:exc.exc}) vastab kahe arvutuse järjestikusele sooritamisele.
Kui esimene osaarvutus õnnestub, siis kogu arvutuse efekt on määratud teise osaarvutuse efektiga.
Kui üks osaarvutustest ebaõnnestub, siis ebaõnnestub kogu arvutus.
Ülejäänud juhtudel puudub teadmine arvutuse õnnestumisest või ebaõnnestumisest.
Efektide korrutamist kasutatakse {\tt LET_IN_} arvutuse tüüpimisel (alaptk~\ref{ssec:exc.raw}).

Erandikäsitleja võib parandada kogu arvutuse efekti hinnangut.
Põhiarvutuse ja erandikäsitleja efektide kombineerimise tehe {\tt _⊹_} on defineeritud joonisel~\ref{fig:exc.exc}.
Kui põhiarvutus ebaõnnestub, siis on kogu arvutuse efekt määratud erandikäsitleja efektiga.
Põhiarvutuse õnnestumisel on kogu arvutus õnnestunud ja erandikäsitlejat ei arvutata.
Kui põhiarvutuse õnnestumine pole teada, aga erandikäsitleja kindlasti õnnestub, siis õnnestub ka kogu arvutus.
Ülejäänud juhtudel pole teada, kas kogu arvutus tervikuna õnnestub või mitte.
Niisugune efekti hinnangu parandus leiab aset {\tt TRY_WITH_} arvutuse tüüpimisel (alaptk~\ref{ssec:exc.raw}).

Hinnangute hulga {\tt Exc} konstruktorid moodustavad järgneva võre:
\begin{center}
  \begin{tikzpicture}[node distance=1.5cm]
    \node (top) at (0,0) {errok};
    \node [below left  of=top] (left)  {err};
    \node [below right of=top] (right) {ok};
    \draw (top) -- (left);
    \draw (top) -- (right);
  \end{tikzpicture}
\end{center}
Hinnangute osaline järjestusseos {\tt _⊑_} on toodud joonisel~\ref{fig:exc.ord}.
See seos on definitsiooni järgi refleksiivne {\tt ⊑-refl}.
Transitiivsus {\tt ⊑-trans} on tõestatav argumentide kuju juhtude läbivaatuse abil.
Transitiivsuse seost on võimalik kodeerida järjestusseose konstruktorina, kuid see pole otstarbekas,
kuna hilisemates tõestuses tekivad sellest täiendavad juhtumid, mida peab analüüsima.

\begin{figure}
  \begin{BVerbatim}
data _⊑_ : Exc → Exc → Set where
  ⊑-refl : {e : Exc} → e ⊑ e
  err⊑errok : err ⊑ errok
  ok⊑errok : ok ⊑ errok
  
⊑-trans : {e e' e'' : Exc} → e ⊑ e' → e' ⊑ e'' → e ⊑ e''
⊑-trans ⊑-refl q = q
⊑-trans err⊑errok ⊑-refl = err⊑errok
⊑-trans ok⊑errok ⊑-refl = ok⊑errok

_⊔_ : Exc → Exc → Exc
_⊓_ : Exc → Exc → Maybe Exc
⊔-sym : (e e' : Exc) → e ⊔ e' ≡ e' ⊔ e
⊓-sym : (e e' : Exc) → e ⊓ e' ≡ e' ⊓ e

lub : (e e' : Exc) → e ⊑ (e ⊔ e')
glb : (e e' : Exc) {e'' : Exc} → e ⊓ e' ≡ just e'' → e'' ⊑ e
  \end{BVerbatim}
  \caption{Erandite efektide järjestus.}
  \label{fig:exc.ord}
\end{figure}
Loomulikul viisil saab defineerida kahe erandi hinnangu ülemise ja alumise raja ning näidata nende sümmeetrilisust.
Lihtsuse huvides on toodud ainult vastavad tüübisignatuurid, aga mitte definitsioonid (jn~\ref{fig:exc.ord}).
Kuna kahel hinnangul ei pruugi alumist raja leiduda, siis on {\tt _⊓_} tulemus mähitud {\tt Maybe} andmetüüpi.

\subsubsection{Eeljärjestatud monoid}\label{sssec:ordered-monoid}
Hulka {\tt E}, millel on defineeritud korrutamine {\tt _·_} ja ühikelement {\tt i},
st {\tt i} on ühik korrutamise suhtes nii vasakult {\tt lu} kui ka paremalt {\tt ru},
ning korrutamine on assotsiatiivne {\tt ass}, nimetatakse monoidiks.
Kui sellel hulgal on määratud kahekohaline seos {\tt _⊑_},
mis on refleksiivne {\tt ⊑-refl} ja transitiivne {\tt ⊑-trans},
ning kehtib korrutamise monotoonsus {\tt mon},
siis on tegemist eeljärjestatud monoidiga.
Joonisel~\ref{fig:ordered-monoid} on toodud eeljärjestatud monoidi kirje tüüp Agdas.

\begin{figure}
  \begin{BVerbatim}
record OrderedMonoid : Set where
  field
    E : Set
    _·_ : E → E → E    
    i : E

    lu : {e : E } → i · e ≡ e
    ru : {e : E } → e ≡ e · i 
    ass : {e e' e'' : E} → (e · e') · e'' ≡ e · (e' · e'')
    
    _⊑_ : E → E → Set    
    ⊑-refl : {e : E} → e ⊑ e
    ⊑-trans : {e e' e'' : E} → e ⊑ e' → e' ⊑ e'' → e ⊑ e''

    mon : {e e' e'' e''' : E} → e ⊑ e'' → e' ⊑ e''' → e · e' ⊑ e'' · e'''
  \end{BVerbatim}
  \caption{Eeljärjestatud monoidi andmetüüp.}
  \label{fig:ordered-monoid}
\end{figure}

Saab näidata, et erandite efekti hinnang {\tt Exc},
korrutamine {\tt _·_}, mille ühikuks on konstruktor {\tt ok},
ja osaline järjestusseos {\tt _⊑_} moodustavad eeljärjestatud monoidi.
Vasakühiku tõestus tuleneb vahetult korrutamise definitsioonist.
Paremühiku tõestamisel tuleb teostada varjatud argumendi konstruktori kuju juhtude läbivaatus
ja seejärel lähtuda korrutamise definitsioonist.
Assotsiatiivsus tõestatakse sarnaselt kasutades juhtude läbivaatust ja korrutamise definitsiooni. Monotoonsuse tõestuses vaadatakse läbi nii võimalikke efekte kui ka nendevahelisi järjestusseoseid.
Kõik mainitud tõestused on toodud töö käigus valminud lähtekoodis.


\subsubsection{Gradeeritud monaad}\label{sssec:graded-monad}

Monaad on järgnev kolmik: tüübikonstruktor {\tt T}, ühik {\tt η} (Haskell'i ``return'') ja nn Kleisli laiendamise operatsioon ehk sidumine {\tt bind}\footnote{Antud töös on {\tt bind}-i argumentide järjekord vahetunud võrreldes tavapärase käsitlusega.}.
\begin{equation*}
\begin{BVerbatim}
T : Set → Set
η : {X : Set} → X → T X
bind : {X Y : Set} → (X → T Y) → (T X → T Y)
\end{BVerbatim}
\end{equation*}
Seejuures peavad olema täidetud kolm monaadi seadust: vasakühik {\tt mlaw1}, paremühik {\tt mlaw2} ja assotsiatiivsus {\tt mlaw3}.
\begin{equation*}
\begin{BVerbatim}
mlaw1 : {X Y : Set} → (f : X → T Y) → (x : X) → bind f (η x) ≡ f x
mlaw2 : {X : Set} → (c : T X) → c ≡ bind η c
mlaw3 : {X Y Z : Set} → (f : X → T Y) → (g : Y → T Z) → (c : T X) →
        bind g (bind f c) ≡ bind (bind g ∘ f) c
\end{BVerbatim}
\end{equation*}

Joonisel~\ref{fig:graded-monad} on toodud eeljärjestatud monoidiga {\tt OM} gradeeritud monaadi kirje tüüp Agdas.
Efektiga {\tt E} parametriseeritud tüübikonstruktor {\tt T} koos ühikuga {\tt η} ja sidumistehtega {\tt bind} moodustab gradeeritud monaadi.
Neelduvusega {\tt sub} saab kahe efekti järjestatuse tõestusele tuginedes luua mingist monaadilisest väärtusest vastavalt suurema efektiga monaadilise väärtuse.
Neelduvus {\tt sub} peab olema refleksiivne {\tt sub-refl}, transitiivne {\tt sub-trans} ja  sidumise suhtes monotoonne {\tt sub-mon}.
Samuti peavad olema täidetud gradeeritud versioonid monaadi seadustest {\tt mlaw1}, {\tt mlaw2} ja {\tt mlaw3}. Viimaste juures on kasutatud neelduvuse erijuhtu {\tt sub-eq} efektide võrdsuse korral pääsemaks mööda Agda tüübisüsteemist: ekvivalentsust ei saa tõestada eri tüüpi elementidele.

\begin{figure}
  \begin{BVerbatim}
subeq : {E : Set} → {T : E → Set → Set} → {e e' : E} → {X : Set} →
        e ≡ e' → T e X → T e' X
subeq refl p = p


record GradedMonad : Set where
  field
    OM : OrderedMonoid
  open OrderedMonoid OM
  field

    T : E → Set → Set
    η : {X : Set} → X → T i X
    bind : {e e' : E} {X Y : Set} → (X → T e' Y) → (T e X → T (e · e') Y)

    sub : {e e' : E} {X : Set} → e ⊑ e' → T e X → T e' X

    sub-mon : {e e' e'' e''' : E} {X Y : Set} →
              (p : e ⊑ e'') → (q : e' ⊑ e''') → 
              (f : X → T e' Y) → (c : T e X) → 
              sub (mon p q) (bind f c) ≡ bind (sub q ∘ f) (sub p c) 

  sub-eq : {e e' : E} {X : Set} → e ≡ e' → T e X → T e' X
  sub-eq = subeq {E} {T}
 
  field
    sub-refl : {e : E} {X : Set} → (c : T e X) → sub ⊑-refl c ≡ c
    sub-trans : {e e' e'' : E} {X : Set} →
                (p : e ⊑ e') → (q : e' ⊑ e'') → (c : T e X) → 
                sub q (sub p c) ≡ sub (⊑-trans p q) c   

    mlaw1 : {e : E} → {X Y : Set} → (f : X → T e Y) → (x : X) →
            sub-eq lu (bind f (η x)) ≡ f x
    mlaw2 : {e : E} → {X : Set} → (c : T e X) →
            sub-eq ru c ≡ bind η c
    mlaw3 : {e e' e'' : E} → {X Y Z : Set} →
            (f : X → T e' Y) → (g : Y → T e'' Z) → (c : T e X) → 
            sub-eq ass (bind g (bind f c)) ≡ bind (bind g ∘ f) c 
  \end{BVerbatim}
  \caption{Gradeeritud monaadi andmetüüp.}
  \label{fig:graded-monad}
\end{figure}

Erandite järjestatud monoidi jaoks saab defineerida gradeeritud monaadi. Joonisel~\ref{fig:exc.graded-monad} on toodud olulisemad definitsioonid.
Tüübikonstruktor {\tt T} on defineeritud erandi hinnangu argumendi kuju järgi: veale {\tt err} vastab üheelemendile hulk {\tt ⊤}, õnnestumisele {\tt ok} parameetriga antud hulk {\tt X} ja hinnangule {\tt errok} vastab hulk {\tt Maybe X}.
Ühikuks {\tt η} on identsusfunktsioon.
Sidumise {\tt bind} definitsioonil on analüüsitud kummagi efekti kuju ning vajadusel ka monaadilise väärtuse kuju.
Neelduvus {\tt sub} annab efektide refleksiivsuse {\tt ⊑-refl} korral monaadilise väärtuse {\tt c} enda.
Kui järjestuse tõestuse esimeseks efektis on {\tt err}, siis vastavalt tüübikonstruktori definitsioonile saab argument olla hulga {\tt ⊤} ainus element {\tt tt}, millele pannakse vastavusse {\tt nothing}.
Kui aga efektiks on {\tt ok}, siis vastav väärtus {\tt x} mähitakse {\tt Maybe X} hulka.

\begin{figure}
  \begin{BVerbatim}
T : Exc → Set → Set
T err X = ⊤
T ok X = X
T errok X = Maybe X

η : {X : Set} → X → T ok X
η x = x
  
bind : {e e' : Exc} {X Y : Set} →
       (X → T e' Y) → T e X → T (e · e') Y
bind {err} f x = tt
bind {ok} f x = f x
bind {errok} {err} f x = tt
bind {errok} {ok} f (just x) = just (f x)
bind {errok} {ok} f nothing = nothing
bind {errok} {errok} f (just x) = f x
bind {errok} {errok} f nothing = nothing

sub : {e e' : Exc} {X : Set} → e ⊑ e' → T e X → T e' X
sub ⊑-refl c = c
sub err⊑errok tt = nothing
sub ok⊑errok x = just x
  \end{BVerbatim}
  \caption{Osa erandite gradeeritud monaadi definitsioonist.}
  \label{fig:exc.graded-monad}
\end{figure}

\subsection{Tüübi- ja efektituletus}\label{ssec:exc.inference}

\subsubsection{Alamtüübid}\label{ssec:exc.subtypes}
Väärtus- ja arvutustüüpide osaline järjestus on vastastikku defineeritud (jn~\ref{fig:exc.subtypes}).
Konstruktoriga {\tt st-bn} loetakse tõeväärtused naturaalarvude alamtüübiks.
Kehtib väärtustüüpide refleksiivsus {\tt st-refl}.
Kahe väärtustüübi korrutis on teise sarnase korrutise alamtüüp {\tt st-prod}, kui vastavad tegurid on alamtüübid.
Funktsiooniruumid on alamtüübid {\tt st-func}, kui tagastustüübid on alamtüübid,
ja argumenditüübid on ülemtüübid.
Arvutustüüp on teise arvutustüübi alamtüüp {\tt st-comp}, kui nende efektid ja väärtustüübid on järjestatud.
\begin{figure}
  \begin{BVerbatim}
mutual
  data _≤V_ : VType → VType → Set where
    st-bn : bool ≤V nat
    st-refl : {σ : VType} → σ ≤V σ
    st-prod : {σ σ' τ τ' : VType} →
              σ ≤V σ' → τ ≤V τ' → σ ● τ ≤V σ' ● τ'
    st-func : {σ σ' : VType} {τ τ' : CType} →
              σ' ≤V σ → τ ≤C τ' → σ ⇒ τ ≤V σ' ⇒ τ'

  data _≤C_ : CType → CType → Set where
    st-comp : {e e' : E} {σ σ' : VType} →
              e ⊑ e' → σ ≤V σ' → e / σ ≤C e' / σ'

mutual
  st-trans : {σ σ' σ'' : VType} → σ ≤V σ' → σ' ≤V σ'' → σ ≤V σ''
  st-trans st-refl q = q
  st-trans p st-refl = p
  st-trans (st-prod p p') (st-prod q q') = st-prod (st-trans p q)
                                                   (st-trans p' q')
  st-trans (st-func p p') (st-func q q') = st-func (st-trans q p)
                                                   (sct-trans p' q')

  sct-trans : {σ σ' σ'' : CType} → σ ≤C σ' → σ' ≤C σ'' → σ ≤C σ''
  sct-trans (st-comp p q) (st-comp p' q') = st-comp (⊑-trans p p')
                                                    (st-trans q q')
  \end{BVerbatim}
  \caption{Väärtus- ja arvutustüüpide alamtüüpimine.}
  \label{fig:exc.subtypes}
\end{figure}

Väärtus- ja arvutustüüpide alamtüüpimise transitiivsus on tõestatud vastastikku joonisel~\ref{fig:exc.subtypes}.
Kui kahe väärtustüüpide alamtüüpimise väite tõestusest üks on alamtüüpimise refleksiivsuse aksioomi {\tt st-refl} kujul, siis transitiivsuse tõestuseks on teine etteantud tõestus.
Kui üks etteantud tõestustest on koostatud reeglist {\tt st-prod},
siis ka teine tõestus peab olema paratamatult samal kujul.
Sellisel juhul on transitiivsuse tõestus saadav reegli {\tt st-prod} rakendamisega rekursiivelt määratud tegurite transitiivsuste {\tt st-trans} tõestustele.
Kui üks etteantud tõestustest on koostatud reeglist {\tt st-func},
siis on seda paratamatult ka teine tõestus.
Sellisel juhul tõestatakse transitiivsus reegli {\tt st-func} rakendamisega rekursiivselt väljakutsutud argumentide transitiivsuse {\tt st-trans} ja kehade arvutustüüpide transitiivsuse {\tt sct-trans} tõestustele.
Tähelepanu tuleb seejuures pöörata funktsiooni argumentide alamtüüpimise transitiivsusele, kuna funktsiooni argumendid on kontravariantsed.

Arvutustüüpide alamtüüpimise transitiivsuse {\tt sct-trans} (jn~\ref{fig:exc.subtypes}) argumendid saavad olla ainult reegli {\tt st-comp} kujul. Transitiivsuse tõestus saadakse reegli {\tt st-comp} rakendamisega efektide järjestuse transitiivsuse {\tt ⊑-trans} ja väärtustüüpide alamtüüpimise transitiivsuse {\tt st-trans} tõestustele.

\subsubsection{Rafineeritud keel}

Joonisel~\ref{fig:exc.refined} on toodud vastastikku defineeritud rafineeritud väärtus- ja arvutustermid.
Võrreldes alaptk~\ref{ssec:exc.raw}-s toodud termidega, on rafineeritud termid parametriseeritud kontekstiga {\tt Γ} ning indekseeritud vastavalt väärtus- ja arvutustüüpidega.
Kontekst {\tt Ctx} on defineeritud kui väärtusttüüpide list, mille elementide järjekord vastab vabade muutujate sissetoomise järjekorrale.
\begin{itemize}
\item Konstruktorid {\tt TT} ja {\tt FF} koostavad tõeväärtustüüpi termid tõeväärtuste tõsi ja väär jaoks.
\item Konstruktor {\tt ZZ} koostab naturaalarvu tüüpi termi arvu 0 tähistamiseks. Konstruktor {\tt SS} koostab termi antud naturaalarvu tüüpi termi järgarvu tähistamiseks, mis on samuti naturaalarvu tüüpi.
\item {\tt ⟨_,_⟩} koostab kahest antud väärtustermist paari, mille tüüp on termide tüüpide korrutis.
\item {\tt FST} ja {\tt SND} projekteerivad paari tüüpi termist vastavalt esimese või teise korrutatava tüüpi termi.
\item {\tt VAR} konstrueerib vaba muutuja ja võtab tõestuse, et mingi tüüp on konteksti element, ning annab väärtustermi, mille tüüp on kõnealuse elemendiga määratud tüüp.
\item {\tt LAM} võtab väärtustüübi ja arvutustermi, mille konteksti on parameetriga antud kontekstiga võrreldes väärtustüübiga laiendatud, ning annab funktsioonile vastava väärtustermi.
\item {\tt VCAST} suurendab etteantud väärtustermi tüüpi vastavalt etteantud alamtüüpimise tõestusele. See võimaldab eri tüüpi väärtustermide tüüpe ühtlustada, mis on vajalik rafineeritud arvutustermide koostamisel.
\end{itemize}

\begin{figure}
  \begin{BVerbatim}
Ctx = List VType

mutual
 data VTerm (Γ : Ctx) : VType → Set where
   TT FF : VTerm Γ bool
   ZZ : VTerm Γ nat
   SS : VTerm Γ nat → VTerm Γ nat
   ⟨_,_⟩ : {σ σ' : VType} →
           VTerm Γ σ → VTerm Γ σ' → VTerm Γ (σ ● σ')
   FST : {σ σ' : VType} → VTerm Γ (σ ● σ') → VTerm Γ σ
   SND : {σ σ' : VType} → VTerm Γ (σ ● σ') → VTerm Γ σ'
   VAR : {σ : VType} → σ ∈ Γ → VTerm Γ σ
   LAM : (σ : VType) {τ : CType} →
         CTerm (σ ∷ Γ) τ → VTerm Γ (σ ⇒ τ)
   VCAST : {σ σ' : VType} → VTerm Γ σ → σ ≤V σ' → VTerm Γ σ'

 data CTerm (Γ : Ctx) : CType → Set where
   VAL : {σ : VType} → VTerm Γ σ → CTerm Γ (ok / σ)
   FAIL : (σ : VType) → CTerm Γ (err / σ)
   TRY_WITH_ : {e e' : E} {σ : VType} → CTerm Γ (e / σ) →
               CTerm Γ (e' / σ) → CTerm Γ (e ⊹ e' / σ)
   IF_THEN_ELSE_ : {e e' : E} {σ : VType} → VTerm Γ bool →
               CTerm Γ (e / σ) → CTerm Γ (e' / σ) → CTerm Γ (e ⊔ e' / σ)
   _$_ : {σ : VType} {τ : CType} →
         VTerm Γ (σ ⇒ τ) → VTerm Γ σ → CTerm Γ τ
   PREC : {e e' : E} {σ : VType} → VTerm Γ nat →
          CTerm Γ (e / σ) → CTerm (σ ∷ nat ∷ Γ) (e' / σ) →
          e · e' ⊑ e → CTerm Γ (e / σ)
   LET_IN_ : {e e' : E} {σ σ' : VType} → CTerm Γ (e / σ) →
             CTerm (σ ∷ Γ) (e' / σ') → CTerm Γ (e · e' / σ')
   CCAST : {e e' : E} {σ σ' : VType} → CTerm Γ (e / σ) →
           e / σ ≤C e' / σ' → CTerm Γ (e' / σ')
  \end{BVerbatim}
  \caption{Eranditega keele rafineeritud termid.}
  \label{fig:exc.refined}
\end{figure}

Rafineeritud arvutustermid (jn~\ref{fig:exc.refined}) määravad täpselt osaarvutuste efektide kombineerimise.
\begin{itemize}
\item {\tt VAL} koostab antud väärtustermist õnnestunud arvutuse.
\item {\tt FAIL} koostab etteantud väärtustüüpi ebaõnnestunud arvutuse.
\item {\tt TRY_WITH_} parandab põhiarvutustermi efekti erandikäsitleja arvutustermi efektiga. Kitsendusena peavad arvutustermid omama sama väärtustüüpi.
\item {\tt IF_THEN_ELSE_} eeldab tõeväärtustüüpi tingimust. Kogu arvutustermi efekt on määratud harude, mille väärtustüübid peavad ühtima, efektide ülemise rajaga.
\item {\tt _\$_} rakendab esimese väärtustermiga antud funktsiooni teise väärtustermiga antud argumendile, seejuures peavad funktsiooni parameetri ja argumendi väärtustüübid ühtima. Saadud arvutuse efekt ja väärtustüüp on määratud funktsiooni keha arvutustüübiga. 
\item {\tt PREC} eeldab sammude arvuna naturaalarvude tüüpi väärtustermi. Baasarvutuse väärtustüüp on lisatud koos naturaalarvu tüüpi sammuloenduriga sammu arvutustermi konteksti. Täiendava kitsendusena on nõutud, et baasi efekt oleks sammu efektiga korrutamise püsipunkt.
\item {\tt LET_IN_} lisab esimese arvutustermi väärtustüübi teise arvutustermi konteksti. Kogu arvutuse efektiks on kahe arvutustermi efektide korrutis ning väärtustüüp on määratud teise arvutustermi tüübiga.
\item {\tt CCAST} suurendab etteantud arvutustermi tüüpi vastavalt alamtüüpimise tõestusele.
\end{itemize}


\subsubsection{Termide tüübituletus}\label{sssec:exc.infer-type}

Etteantud kontekstis saab väärtustermile tuletada vastava väärtustüübi (jn~\ref{fig:exc.infer-vtype}).
Kuna term võib olla tüüpimatu, siis on {\tt infer-vtype} tulemus mähitud {\tt Maybe} andmetüüpi.
Väärtustüübi tuletamisel lähtutakse väärtustermi kujust.
\begin{itemize}
\item {\tt TT} ja {\tt FF} annavad kindlasti tõeväärtustüübi.
\item {\tt ZZ} on kindlasti naturaalarvu tüüpi. {\tt SS t} korral tuleb täiendavalt kontrollida, kas term {\tt t} on samas kontekstis naturaalarvu tüüpi. Vastasel korral on term halvasti koostatud ja seda ei saa tüüpida.
\item Paari {\tt ⟨ t , t' ⟩} tüüp on määratud, kui termide {\tt t} ja {\tt t'} tüübid on samas kontekstis määratud. Paari tüübiks on nende termide tüüpide korrutis. Ülejäänud juhtudel pole paari tüüp määratud.
\item {\tt FST t} ja {\tt SND t} on määratud, kui term {\tt t} on paar, st antud kontekstis on ta korrutise tüüpi. Projektsiooni tüübiks on vastavalt esimene või teine tegur.
\item {\tt VAR x} korral tuleb kontrollida, et naturaalarv {\tt x} on väiksem kui konteksti {\tt Γ} pikkus. Selleks on kasutatud lahendajat {\tt _<?_}. Naturaalarvude võrratuse tõestusest {\tt p} on koostatud konteksti pikkusega piiratud naturaalarv {\tt fromℕ≤ p}, mida kasutatakse muutujale vastava tüübi otsimiseks kontekstist {\tt lkp Γ}.
\item {\tt LAM σ t} puhul tuleb kontrollida, et arvutustermiga {\tt t} antud funktsiooni keha on hästi tüübitud kontekstis, mida on laiendatud parameetri väärtustüübi {\tt σ} võrra. Arvutustermi tüübituletus {\tt infer-ctype} on toodud allpool.
\end{itemize}

\begin{figure}
  \begin{BVerbatim}
infer-vtype : Ctx → vTerm → Maybe VType
infer-vtype Γ TT = just bool
infer-vtype Γ FF = just bool
infer-vtype Γ ZZ = just nat
infer-vtype Γ (SS t) with  infer-vtype Γ t
... | just nat = just nat
... | _        = nothing
infer-vtype Γ ⟨ t , t' ⟩ with infer-vtype Γ t | infer-vtype Γ t'
... | just σ | just σ' = just (σ ● σ')
... | _      | _       = nothing
infer-vtype Γ (FST t) with infer-vtype Γ t
... | just (σ ● _) = just σ
... | _            = nothing
infer-vtype Γ (SND t) with infer-vtype Γ t
... | just (_ ● σ') = just σ'
... | _             = nothing
infer-vtype Γ (VAR x) with x <? Γ
... | yes p = just (lkp Γ (fromℕ≤ p))
... | no ¬p = nothing
infer-vtype Γ (LAM σ t) with infer-ctype (σ ∷ Γ) t
... | just τ = just (σ ⇒ τ)
... | _      = nothing
  \end{BVerbatim}
  \caption{Eranditega keele väärtustermide tüübituletus.}
  \label{fig:exc.infer-vtype}
\end{figure}

Joonisel~\ref{fig:exc.infer-ctype} on toodud etteantud kontekstis arvutustermile tüübi tuletamine.
Nagu väärtustermide tüübituletuse puhul, on ka arvutustermide tüübituletus {\tt infer-ctype} tulemus mähitud {\tt Maybe} andmetüüpi.
Arvutustüübi tuletamisel lähtutakse arvutustüübi kujust.
\begin{itemize}
\item {\tt VAL x} on tüübitud, kui väärtustermi {\tt x} tüübituletus õnnestub. Arvutuse väärtustüübiks on tuletatud tüüp. Efektihinnang {\tt ok} tähistab arvutuse õnnestumist. 
\item {\tt FAIL σ} on alati väärtustüübi {\tt σ} ebaõnnestumise tüüpi, mille efektihinnang on {\tt err}.
\item {\tt TRY t WITH t'} on tüübitud, kui arvutustermid {\tt t} ja {\tt t'} on hästi tüübitud. Kogu arvutuse tüübiks on põhiarvutuse tüübi {\tt τ} parandamine erandikäsitleja tüübiga {\tt τ'}. Arvutustüüpide parandus _⊹C_ on defineeritud efektide paranduse _⊹_ ja väärtustüüpide ülemise raja _⊔V_ abil.
\item {\tt IF x THEN t ELSE t'} eeldab, et väärtusterm {\tt x} on tõeväärtustüüpi. Kogu arvutuse tüüp on määratud harude tüüpide {\tt τ} ja {\tt τ'} ülemise rajaga {\tt τ ⊔C τ'}.
\item {\tt f \$ t} korral kontrollitakse, et väärtustermi {\tt f} tüübiks on funktsiooniruum ja väärtustermile {\tt t} tuletatud tüüp on {\tt f} parameetri (ehk uusima vaba muutuja) alamtüüp. Ülejäänud juhtudel ei ole funktsiooni rakendamine hästi tüübitud.
\item {\tt PREC x t t'} korral kontrollitakse viit tingimust.
  \begin{itemize}
  \item Väärtusterm {\tt x} peab olema antud kontekstis naturaalarvu tüüpi.
  \item Baasi arvutusterm {\tt t} peab olema antud kontekstis hästi tüübitud.
  \item Sammu arvutusterm {\tt t'} peab olema tüübitud kontekstis, kuhu on lisatud naturaalarvu tüüpi sammuloendur ja arvutustermi {\tt t} väärtustüüpi {\tt σ} akumulaator.
  \item Osaarvutustele {\tt t} ja {\tt t'} tuletatud väärtustüübid peavad olema samad. Selleks kasutatakse lahendajat {\tt _≡V?_}.
  \item Osaarvutuste {\tt t} ja {\tt t'} efektide korrutis ei tohi olla suurem kui baasi {\tt t} efekt. Seda kontrollitakse lahendajaga {\tt _⊑?_}.
  \end{itemize}
  Kui kõik tingimused kehtivad, siis kogu arvutuse tüüp on määratud baasi efekti ja väärtustüübiga.
\item {\tt LET t IN t'} on tüübitud, kui arvutusterm {\tt t} on tüübitud antud kontekstis ja arvutusterm {\tt t'} on tüübitud kontekstis, mida on laiendatud {\tt t} väärtustüübi võrra. Arvutuse efektiks on {\tt t} ja {\tt t'} efektide korrutis ning väärtustüübiks {\tt t'} väärtustüüp. Kui üks termidest {\tt t} ja {\tt t'} ei ole hästi tüübitud, siis ei ole ka kogu term tüübitud.
\end{itemize}

\begin{figure}
  \begin{BVerbatim}
infer-ctype : Ctx → cTerm → Maybe CType
infer-ctype Γ (VAL x) with infer-vtype Γ x
... | just σ = just (ok / σ)
... | _      = nothing
infer-ctype Γ (FAIL σ) = just (err / σ)
infer-ctype Γ (TRY t WITH t') with infer-ctype Γ t | infer-ctype Γ t'
... | just τ | just τ' = τ ⊹C τ'
... | _      | _       = nothing
infer-ctype Γ (IF x THEN t ELSE t')
    with infer-vtype Γ x | infer-ctype Γ t | infer-ctype Γ t'
... | just bool | just τ | just τ' = τ ⊔C τ'
... | _         | _      | _       = nothing
infer-ctype Γ (f $ t) with infer-vtype Γ f | infer-vtype Γ t
... | just (σ ⇒ τ) | just σ' with σ' ≤V? σ
...                           | yes _ = just τ
...                           | no  _ = nothing
infer-ctype Γ (f $ t) | _ | _ = nothing
infer-ctype Γ (PREC x t t')
    with infer-vtype Γ x
... | just nat with infer-ctype Γ t
...        | nothing = nothing
...        | just (e / σ) with infer-ctype (σ ∷ nat ∷ Γ) t'
...                       | nothing = nothing
...                       | just (e' / σ') with e · e' ⊑? e | σ ≡V? σ'
...                                        | yes _ | yes _ = just (e / σ)
...                                        | _     | _     = nothing
infer-ctype Γ (PREC x t t') | _ = nothing
infer-ctype Γ (LET t IN t') with infer-ctype Γ t 
... | nothing = nothing
... | just (e / σ) with infer-ctype (σ ∷ Γ) t'
...                | nothing        = nothing
...                | just (e' / σ') = just (e · e' / σ')
  \end{BVerbatim}
  \caption{Eranditega keele arvutustermide tüübituletus.}
  \label{fig:exc.infer-ctype}
\end{figure}

\subsubsection{Termide rafineerimine}

Kui n-ö ``toorele'' termile õnnestub mingis kontekstis tuletada tüüp, siis saab sellest termist konstrueerida n-ö ``rafineeritud'' termi, mis ``teab'' oma konteksti ja tüüpi.
Joonisel~\ref{fig:exc.infer-term-type} on toodud rafineeritud väärtus- ja arvutustermide tüübikonstruktorid.
Üheelemendiline hulk {\tt ⊤} tähistab tüübituletuse ebaõnnestumist.
\begin{figure}
  \begin{BVerbatim}
refined-vterm : Ctx → vTerm → Set
refined-vterm Γ t with infer-vtype Γ t 
... | nothing = ⊤
... | just τ = VTerm Γ τ

refined-cterm : Ctx → cTerm → Set
refined-cterm Γ t with infer-ctype Γ t 
... | nothing = ⊤
... | just τ = CTerm Γ τ
  \end{BVerbatim}
  \caption{Väärtus- ja arvutustermide rafineerimiste tüübikonstruktorid.}
  \label{fig:exc.infer-term-type}
\end{figure}

Väärtustermide rafineerimine etteantud kontekstis (jn~\ref{fig:exc.refine-vterm}) matkib väärtustermide tüübituletust (alaptk~\ref{sssec:exc.infer-type}).
\begin{itemize}
\item {\tt TT} ja {\tt FF} korral konstrueeritakse vastav rafineeritud väärtusterm.
\item {\tt ZZ} puhul konstrueeritakse nullile vastav rafineeritud väärtusterm {\tt ZZ}. {\tt SS t} korral kontrollitakse, et väärtusterm {\tt t} on hästi tüübitud ja on naturaalarvu tüüpi. Rafineeritud järgarv {\tt SS} koostatakse termi {\tt t} rafineeringust {\tt u}. Kui väärtustermi {\tt t} tüübituletus ei õnnestu või tuletatud tüüp ei ole naturaalarvu tüüpi, siis rafineeringu tulemuseks on tüübi {\tt ⊤} ainus element {\tt tt}.
\item {\tt ⟨ t , t' ⟩} korral kontrollitakse, et mõlemad väärtustermid {\tt t} ja {\tt t'} on kontekstis hästi tüübitud ja rafineeritud paar koostatakse rafineeritud termidest {\tt u} ja {\tt u'}.
\item {\tt FST t} puhul peab väärtustermile {\tt t} tuletatud tüüp olema korrutistüüp. Rafineeritud projektsiooni saab koostada {\tt t} rafineeringust {\tt u}. {\tt SND t} juhtum on analoogne.
\item {\tt VAR x} korral koostatakse tõestusest {\tt p}, mis näitab, et naturaalarv {\tt x} on väiksem kui konteksti {\tt Γ} pikkus, rafineeritud muutuja tõestusega, et {\tt x}-ile määratud kohal kontekstis {\tt Γ} on {\tt VAR x} jaoks tuletatud tüüp.
\item {\tt LAM σ t} juhtumis lisatakse parameetri tüüp {\tt σ} konteksti ja kontrollitakse arvutustermi {\tt t} hästi-tüübitust. Rafineeritud funktsiooniabstraktsioon koostatakse uues kontekstis rafineeritud arvutusest {\tt u}.
\end{itemize}

\begin{figure}
  \begin{BVerbatim}
refine-vterm : (Γ : Ctx) (t : vTerm) → refined-vterm Γ t 
refine-vterm Γ TT = TT
refine-vterm Γ FF = FF
refine-vterm Γ ZZ = ZZ
refine-vterm Γ (SS t) with infer-vtype Γ t | refine-vterm Γ t
... | just nat | u = SS u
... | just bool | _ = tt
... | just (_ ● _) | _ = tt
... | just (_ ⇒ _) | _ = tt
... | nothing | _ = tt
refine-vterm Γ ⟨ t , t' ⟩
    with infer-vtype Γ t | refine-vterm Γ t |
         infer-vtype Γ t' | refine-vterm Γ t'
... | just _  | u | just _  | u' = ⟨ u , u' ⟩
... | just _  | _ | nothing | _  = tt
... | nothing | _ | _       | _  = tt
refine-vterm Γ (FST t) with infer-vtype Γ t | refine-vterm Γ t
... | just nat | _ = tt
... | just bool | _ = tt
... | just (_ ● _) | u = FST u
... | just (_ ⇒ _) | _ = tt
... | nothing | _ = tt
refine-vterm Γ (SND t) with infer-vtype Γ t | refine-vterm Γ t
... | just nat | _ = tt
... | just bool | _ = tt
... | just (_ ● _) | u = SND u
... | just (_ ⇒ _) | _ = tt
... | nothing | _ = tt
refine-vterm Γ (VAR x) with x <? Γ
... | yes p = VAR (trace Γ (fromℕ≤ p))
... | no _  = tt
refine-vterm Γ (LAM σ t)
    with infer-ctype (σ ∷ Γ) t | refine-cterm (σ ∷ Γ) t
... | just _ | u = LAM σ u
... | nothing | u = tt
  \end{BVerbatim}
  \caption{Eranditega keele väärtustermide rafineerimine.}
  \label{fig:exc.refine-vterm}
\end{figure}

Arvutustermide rafineerimine on toodud joonistel~\ref{fig:exc.refine-cterm1} ja~\ref{fig:exc.refine-cterm2}.
\begin{itemize}
\item {\tt VAL t} korral kontrollitakse, et väärtusterm {\tt t} on hästi tüübitud, ja rafineeritud arvutus koostatakse vastavast rafineeritud väärtustermist {\tt u}.
\item {\tt FAIL σ} rafineerimisel näidatakse, et selle arvutustermi tüübituletus alati õnnestub.
\item {\tt TRY t WITH t'} korral kontrollitakse, et {\tt t} ja {\tt t'} on hästi tüübitud ja tuletatud väärtustüüpidel leidub ülemine raja. Rafineeritud arvutuse konstrueerimiseks suurendatakse rafineeritud osaarvutuste {\tt u} ja {\tt u'} tüüpi ülemise rajani vastavalt alamtüüpimise tõestusele {\tt p}.
\item {\tt IF x THEN t ELSE t'} korral peab väärtusterm {\tt x} olema tõeväärtustüüpi ning arvutustermid {\tt t} ja {\tt t'} peavad olema hästi tüübitud. Kui harude {\tt t} ja {\tt t'} arvutuste väärtustüüpidel leidub ülemine raja, siis rafineeritud tingimuslause tingimus on rafineeritud väärtusterm {\tt x'} ja tingimuslause harudes suurendatakse rafineeritud arvutuste {\tt u} ja {\tt u'} tüüpi vastavalt alamtüübi tõestusele {\tt p}. Ülejäänud juhtudel tagastatakse tüübi {\tt ⊤} element {\tt tt}.
\item {\tt f \$ x} korral peab väärtusterm {\tt f} olema funktsiooniruumi tüüpi ja seejuures peab argumendile {\tt x} tuletatud tüüp olema mainitud funktsiooniruumi parameetri tüübi alamtüüp. Rafineeritud funktsiooni {\tt f'} rakendamise koostamisel on rafineeritud argumendi {\tt x'} tüüpi suurendatud vastavalt alamtüübi tõestusele {\tt p}.
\item {\tt PREC x t t'} korral kontrollitakse, et väärtusterm {\tt x} on naturaalarvu tüüpi ning baasile vastav arvutus {\tt t} hästi tüübitud. Seejärel, et sammule vastav arvutus {\tt t'} on hästi tüübitud kontekstis, kuhu on lisatud naturaalarvu tüüpi sammuloendur ning baasi väärtustüübile vastav akumulaator. Viimaks kontrollitakse, et baasi ja sammu efektide korrutamine ei ületaks baasi efekti ning et baasile ja sammule vastavad väärtustüübid langevad kokku. Rafineeritud primitiivse rekursiooni term koostatakse vastavatest rafineeritud termidest {\tt x'}, {\tt u}, {\tt u'} ja efektide korrutamise püsipunkti tõestusest {\tt p}.
\item {\tt LET t IN t'} puhul peab osaarvutus {\tt t} olema hästi tüübitud antud kontekstis ja osaarvutus {\tt t'} tüübitud kontekstis, kuhu on lisatud {\tt t}-le tuletatud tüüp {\tt σ}. Rafineeritud arvutuste sidumine koostatakse rafineeritud osaarvutustest {\tt u} ja {\tt u'}.
\end{itemize}
\begin{figure}
  \begin{BVerbatim}
refine-cterm : (Γ : Ctx) (t : cTerm) → refined-cterm Γ t
refine-cterm Γ (VAL t) with infer-vtype Γ t | refine-vterm Γ t
... | nothing | u = tt
... | just _ | u = VAL u
refine-cterm Γ (FAIL σ) with infer-ctype Γ (FAIL σ)
... | _ = FAIL σ
refine-cterm Γ (TRY t WITH t')
    with infer-ctype Γ t | refine-cterm Γ t |
         infer-ctype Γ t' | refine-cterm Γ t'
... | nothing      | _ | _              | _ = tt
... | just _       | _ | nothing        | _ = tt
... | just (e / σ) | u | just (e' / σ') | u'
         with σ ⊔V σ' | inspect (_⊔V_ σ) σ'
...      | nothing | _ = tt
...      | just _ | [ p ] =
    TRY  CCAST u (⊔V-subtype p)
    WITH CCAST u' (⊔V-subtype-sym {σ} p)
refine-cterm Γ (IF x THEN t ELSE t')
    with infer-vtype Γ x | refine-vterm Γ x
... | nothing | _ = tt
... | just nat | _ = tt
... | just (_ ● _) | _ = tt
... | just (_ ⇒ _) | _ = tt
... | just bool | x'
         with infer-ctype Γ t | refine-cterm Γ t
...      | nothing | u = tt
...      | just (e  / σ) | u
              with infer-ctype Γ t' | refine-cterm Γ t'
...           | nothing | u' = tt
...           | just (e' / σ') | u'
                   with σ ⊔V σ' | inspect (_⊔V_ σ) σ'
...                | nothing | _     = tt
...                | just ⊔σ | [ p ] =
    IF x' THEN CCAST u (⊔V-subtype p)
          ELSE CCAST u' (⊔V-subtype-sym {σ} p)
--
  \end{BVerbatim}
  \caption{Eranditega keele arvutustermide rafineerimine, I osa.}
  \label{fig:exc.refine-cterm1}
\end{figure}
\begin{figure}
  \begin{BVerbatim}
--refine-cterm : (Γ : Ctx) (t : cTerm) → refined-cterm Γ t
refine-cterm Γ (f $ x)
    with infer-vtype Γ f | refine-vterm Γ f |
         infer-vtype Γ x | refine-vterm Γ x
... | nothing   | _ | _ | _ = tt
... | just nat  | _ | _ | _ = tt
... | just bool | _ | _ | _ = tt
... | just (_ ● _) | _ | _ | _ = tt
... | just (_ ⇒ _) | _ | nothing | _ = tt  
... | just (σ ⇒ τ) | f' | just σ' | x' with σ' ≤V? σ
...                                    | no _  = tt
...                                    | yes p = f' $ VCAST x' p
refine-cterm Γ (PREC x t t')  with infer-vtype Γ x | refine-vterm Γ x
... | nothing | _  = tt
... | just bool | _ = tt
... | just (_ ● _) | _ = tt
... | just (_ ⇒ _) | _ = tt
... | just nat | x'
        with infer-ctype Γ t | refine-cterm Γ t 
...     | nothing | _ = tt
...     | just (e / σ) | u
            with infer-ctype (σ ∷ nat ∷ Γ) t' |
                 refine-cterm (σ ∷ nat ∷ Γ) t'
...         | nothing | _ = tt
...         | just (e' / σ') | u' with e · e' ⊑? e | σ ≡V? σ'
...                               | no  _ | _    = tt
...                               | yes _ | no _ = tt
refine-cterm Γ (PREC x t t')
    | just nat | x'
        | just (e / σ) | u
            | just (e' / .σ) | u' | yes p | yes refl = PREC x' u u' p
refine-cterm Γ (LET t IN t') with infer-ctype Γ t | refine-cterm Γ t 
... | nothing | _  = tt
... | just (e / σ) | u with infer-ctype (σ ∷ Γ) t' |
                            refine-cterm (σ ∷ Γ) t'
...                    | nothing        | _  = tt
...                    | just (e' / σ') | u' = LET u IN u'
  \end{BVerbatim}
  \caption{Eranditega keele arvutustermide rafineerimine, II osa.}
  \label{fig:exc.refine-cterm2}
\end{figure}

\subsection{Semantika}\label{ssec:exc.semantics}

Joonisel~\ref{fig:type-semantics} on toodud vastastikku defineeritud väärtus- ja arvutustüüpide ning konteksti semantiline interpretatsioon metakeeles Agda.
\begin{itemize}
\item {\tt nat} interpreteeritakse kui naturaalarvud {\tt ℕ} ja {\tt bool} kui tõeväärtused {\tt Bool}.
\item {\tt σ ● σ'} korral tehakse rekursiivsed väljakutsed korrutatavatele ning tulemused korrutatakse Agdas {\tt _×_}.
\item {\tt σ ⇒ τ} interpretatsioon vastab Agda funktsiooniruumile, mille parameetri ja tulemuse tüüp on interpreteeritud vastavalt väärtustüübist {\tt σ} ja arvutustüübist {\tt τ}.
\item Arvutustüübi {\tt e / σ} interpreteerimiseks rakendatakse gradeeritud monaadi tüübikonstruktorit {\tt T} efektile {\tt e} ja väärtustüübi {\tt σ} interpretatsioonile.
\item Tühi kontekst vastab üheelemendilisele tüübile {\tt ⊤}. Mittetühja konteksti pea interpreteeritakse ja korrutatakse rekursiivselt interpreteeritud sabaga.
\end{itemize}

\begin{figure}
  \begin{BVerbatim}
mutual
  ⟪_⟫V : VType → Set
  ⟪ nat ⟫V = ℕ
  ⟪ bool ⟫V = Bool
  ⟪ σ ● σ' ⟫V = ⟪ σ ⟫V × ⟪ σ' ⟫V
  ⟪ σ ⇒ τ ⟫V = ⟪ σ ⟫V → ⟪ τ ⟫c

  ⟪_⟫c : CType → Set
  ⟪ e / σ ⟫c = T e ⟪ σ ⟫V

⟪_⟫X : Ctx → Set
⟪ [] ⟫X = ⊤
⟪ σ ∷ Γ ⟫X = ⟪ σ ⟫V × ⟪ Γ ⟫X
  \end{BVerbatim}
  \caption{Väärtus-, arvutustüüpide ja konteksti semantika.}
  \label{fig:type-semantics}
\end{figure}

Joonisel~\ref{fig:exc.vterm-semantics} on toodud rafineeritud väärtustermi interpretatsioon antud konteksti interpretatsioonis.
\begin{itemize}
\item {\tt TT} ja {\tt FF} seatakse vastavusse tõese ja vääraga.
\item {\tt ZZ} vastab nullile. {\tt SS t} on {\tt t} interpretatsiooni järgarv.
\item {\tt ⟨ t , t' ⟩} tõlgendatakse kui {\tt t} ja {\tt t'} interpretatsioonide paari.
\item {\tt FST t} ja {\tt SND t} projekteerivad esimese ja teise komponendi {\tt t} interpretatsioonist, mis on paar.
\item {\tt VAR x} projekteerib konteksti interpretatsioonist {\tt ρ} tõestusele {\tt x} vastava (n-ö {\tt x}-nda) väärtuse.
\item {\tt LAM σ t} interpreteeritakse kui lambda abstraktsiooni, mille seotud muutuja {\tt x} lisatakse arvutustermi {\tt t} interpreteerimise konteksti.
\item {\tt VCAST t p} puhul interpreteeritakse väärtusterm {\tt t} ja konverteeritakse see vastavalt alamtüüpimise tõestusele {\tt p}.
\end{itemize}

\begin{figure}
  \begin{BVerbatim}
⟦_⟧V : {Γ : Ctx} {σ : VType} → VTerm Γ σ → ⟪ Γ ⟫X → ⟪ σ ⟫V
⟦ TT ⟧V ρ = true
⟦ FF ⟧V ρ = false
⟦ ZZ ⟧V ρ = zero
⟦ SS t ⟧V ρ = suc (⟦ t ⟧V ρ)
⟦ ⟨ t , t' ⟩ ⟧V ρ = ⟦ t ⟧V ρ , ⟦ t' ⟧V ρ
⟦ FST t ⟧V ρ = proj₁ (⟦ t ⟧V ρ)
⟦ SND t ⟧V ρ = proj₂ (⟦ t ⟧V ρ)
⟦ VAR x ⟧V ρ = proj x ρ
⟦ LAM σ t ⟧V ρ = λ x → ⟦ t ⟧C (x , ρ)
⟦ VCAST t p ⟧V ρ = vcast p (⟦ t ⟧V ρ)
  \end{BVerbatim}
  \caption{Eranditega keele väärtustermide semantika.}
  \label{fig:exc.vterm-semantics}
\end{figure}

Rafineeritud arvutustermi semantiline interpretatsioon etteantud konteksti interpretatsioonis on toodud joonisel~\ref{fig:exc.cterm-semantics}.
\begin{itemize}
\item {\tt VAL x} interpreteerib väärtustermi {\tt x} antud kontekstis ja rakendab sellele gradeeritud monaadi ühikut {\tt η}.
\item Kuna arvutustüübi, mille efekt on {\tt err}, interpretatsioon erandite gradeeritud monaadis on üheelemendiline hulk {\tt ⊤}, siis {\tt FAIL σ} koostab selle ainsa elemendi {\tt tt}.
\item {\tt TRY_WITH_ {e} {e'} t t'} kombineerib osaarvutuste {\tt t} ja {\tt t'} interpretatsioonid vastavalt arvutuste efektidele. Semantiline erandikäsitlus {\tt or-else} käitub järgnevalt. Kui esimese osaarvutuse efektiks on ebaõnnestumine {\tt err}, siis kogu arvutus on määratud erandikäsitlejaga. Kui esimene arvutus õnnestub efektiga {\tt ok}, siis kogu arvutuseks ongi esimene arvutus. Kui esimese arvutuse õnnestumine pole teada, st efektiks on {\tt errok}, siis analüüsitakse ka erandikäsitleja efekti. Kui erandikäsitleja efekt on {\tt err}, siis on kogu arvutus määratud põhiarvutusega. Ülejäänud juhtudel analüüsitakse esimese arvutuse tulemuse kuju: kui esimene arvutus ikkagi õnnestus (konstruktor {\tt just}), siis saab sealt ka kogu arvutuse tulemuse; vastasel korral on kogu arvutuse tulemuseks erandikäsitleja tulemus.
\item {\tt IF_THEN_ELSE_} korral interpreteeritakse tingimus ja harud tingimuslauses, kusjuures kummagi haru efekt neeldub efektide ülemises rajas.
\item {\tt PREC x t t' p} interpretatsioon vastab primitiivsele rekursioonile, mille sammude arv on on väärtustermi {\tt x} interpretatsioon, baas on arvutustermi {\tt t} interpretatsioon ja sammuks on arvutustermi {\tt t'} interpretatsioon kontekstis, kuhu on lisatud sammuloendur ja vahetulemuse akumulaator. Semantiline primitiivne rekursioon {\tt primrecT} on defineeritud induktsiooniga sammude arvul. Nulli korral on tulemuseks baasile vastav arvutus {\tt z}. Sammu korral rakendatakse sammule vastavat funktsiooni {\tt s} sammuloendurile {\tt n} ja saadud funktsioon seotakse rekursiivse väljakutsega gradeeritud monaadi {\tt bind}-tehte abil. Tulemuse efekt neeldub efektide püsipunkti tõestuse {\tt p} tõttu baasarvutuse efektis.
\item {\tt f \$ x} korral rakendatakse väärtustermi {\tt f} interpretatsiooni väärtustermi {\tt x} interpretatsioonile.
\item {\tt LET_IN_} seob arvutuste interpretatsioonid, kasutades gradeeritud monaadi {\tt bind}-tehet.
\item {\tt CCAST t p} puhul interpreteeritakse arvutusterm {\tt t} ja konverteeritakse see vastavalt alamtüüpimise tõestusele {\tt p}.
\end{itemize}

\begin{figure}
  \begin{BVerbatim}
or-else : (e e' : E) {X : Set} → T e X → T e' X → T (e ⊹ e') X
or-else err _ _ x' = x'
or-else ok _ x _ = x
or-else errok err x _ = x
or-else errok ok (just x) _ = x
or-else errok ok nothing x' = x'
or-else errok errok (just x) x' = just x
or-else errok errok nothing x' = x'

primrecT : {e e' : E} {X : Set} →
           ℕ → T e X → (ℕ → X → T e' X) → e · e' ⊑ e → T e X
primrecT zero z s p = z
primrecT {e} {e'} (suc n) z s p =
    sub p (bind {e} {e'} (s n) (primrecT n z s p))

⟦_⟧C : {Γ : Ctx} {τ : CType} → CTerm Γ τ → ⟪ Γ ⟫X → ⟪ τ ⟫c
⟦ VAL x ⟧C ρ = η (⟦ x ⟧V ρ)
⟦ FAIL σ ⟧C ρ = tt
⟦ TRY_WITH_ {e} {e'} t t' ⟧C ρ = or-else e e' (⟦ t ⟧C ρ) ( (⟦ t' ⟧C ρ))
⟦ IF_THEN_ELSE_ {e} {e'} x t t' ⟧C ρ =
    if ⟦ x ⟧V ρ
    then (sub (lub e e') (⟦ t ⟧C ρ))
    else (sub (lub-sym e' e) (⟦ t' ⟧C ρ))
⟦ PREC x t t' p ⟧C ρ = primrecT (⟦ x ⟧V ρ) (⟦ t ⟧C ρ)
                                ((λ i acc → ⟦ t' ⟧C (acc , i , ρ))) p
⟦ f $ x ⟧C ρ = ⟦ f ⟧V ρ (⟦ x ⟧V ρ)
⟦ LET_IN_ {e} {e'} t t' ⟧C ρ =
    bind {e} {e'} (λ x → ⟦ t' ⟧C (x , ρ)) (⟦ t ⟧C ρ)
⟦ CCAST t o ⟧C ρ = ccast o (⟦ t ⟧C ρ)
  \end{BVerbatim}
  \caption{Eranditega keele arvutustermide semantika.}
  \label{fig:exc.cterm-semantics}
\end{figure}

\subsection{Optimisatsioonid}\label{ssec:exc.optimizations}

Etteantud kontekstist saab jätta välja selle mingis kohas oleva tüübi, eeldusel, et sellele vastavat muutujat pole mingis termis tarvis.
Seda nimetatakse konteksti lühendamiseks {\tt dropX} (jn~\ref{fig:weakening}).
Vastavalt saab lõdvendada rafineeritud väärtusterme {\tt wkV} ja arvutusterme {\tt wkC}, nihutades vajadusel sobivalt muutujaid.
Teades konteksti interpretatsiooni ja väljajäetavat muutujat, saab koostada lühendatud konteksti interpretatsiooni {\tt drop}.
Lemmad {\tt lemma-wkV} ja {\tt lemma-wkC} näitavad, et termi interpretatsioon lühendatud kontekstis on sama, mis lõdvendatud termi interpretatsioon algses kontekstis.

Etteantud konteksti saab laiendada dubleerides {\tt dupX} selle mingit elementi (jn~\ref{fig:contraction}).
Termi kontraheerimine, funktsioonid {\tt ctrV} ja {\tt ctrC}, seisneb selle kontekstis olevate muutujate koondamises, eeldusel, et koondatavad on võrdsed (teisisõnu: dubleeritud).
Vajadusel tuleb selleks nihutada muutujaid ühe elemendi võrra.
Konteksti interpretatsioonis saab dubleerida mingile muutujale vastava väärtuse funktsiooniga {\tt dup}.
Lemmad {\tt lemma-ctrV} ja {\tt lemma-ctrC} näitavad, et termi interpretatsioon dubleeritud kontekstis on sama, mis kontraheeritud termi interpretatsioon algses kontekstis.

Lihtsuse huvides pole mainitud lõdvendamise ja kontraheerimise definitsioone ja tõestusi siinkohal toodud.
\begin{figure}
  \begin{BVerbatim}
dropX : (Γ : Ctx) {σ : VType} (x : σ ∈ Γ) → Ctx
-- proof omitted
mutual
  wkV : {Γ : Ctx} {σ σ' : VType} (x : σ ∈ Γ) →
        VTerm (dropX Γ x) σ' → VTerm Γ σ'
  -- proof omitted
  wkC : {Γ : Ctx} {σ : VType} {τ : CType} (x : σ ∈ Γ) →
        CTerm (dropX Γ x) τ → CTerm Γ τ
  -- proof omitted
drop : {Γ : Ctx} → ⟪ Γ ⟫X → {σ : VType} → (x : σ ∈ Γ) → ⟪ dropX Γ x ⟫X 
-- proof omitted
mutual
  lemma-wkV : {Γ : Ctx} (ρ : ⟪ Γ ⟫X) →
              {σ : VType} (x : σ ∈ Γ) →
              {σ' : VType} (t : VTerm (dropX Γ x) σ') →
              ⟦ wkV x t ⟧V ρ ≡ ⟦ t ⟧V (drop ρ x)
  -- proof omitted
  lemma-wkC : {Γ : Ctx} (ρ : ⟪ Γ ⟫X) →
              {σ : VType} (x : σ ∈ Γ) →
              {τ : CType} (t : CTerm (dropX Γ x) τ) →
              ⟦ wkC x t ⟧C ρ ≡ ⟦ t ⟧C (drop ρ x)
  -- proof omitted
\end{BVerbatim}
  \caption{Konteksti lühendamine ja termide lõdvendamine.}
  \label{fig:weakening}
\end{figure}

\begin{figure}
  \begin{BVerbatim}
dupX : {Γ : Ctx} {σ : VType} → σ ∈ Γ → Ctx
-- proof omitted
mutual
  ctrV : {Γ : Ctx} {σ σ' : VType} (p : σ ∈ Γ) →
         VTerm (dupX p) σ' → VTerm Γ σ'
  -- proof omitted
  ctrC : {Γ : Ctx} {σ : VType} {τ : CType} (p : σ ∈ Γ) →
         CTerm (dupX p) τ → CTerm Γ τ
  -- proof omitted
dup : {Γ : Ctx} → ⟪ Γ ⟫X → {σ : VType} → (p : σ ∈ Γ) → ⟪ dupX p ⟫X
-- proof omitted
mutual
  lemma-ctrV : {Γ : Ctx} (ρ : ⟪ Γ ⟫X) →
               {σ : VType} (p : σ ∈ Γ) →
               {σ' : VType} (t : VTerm (dupX p) σ') →
               ⟦ t ⟧V (ctr ρ p) ≡ ⟦ ctrV p t ⟧V ρ
  -- proof omitted
  lemma-ctrC : {Γ : Ctx} (ρ : ⟪ Γ ⟫X) →
               {σ : VType} (p : σ ∈ Γ) →
               {τ : CType} (t : CTerm (dupX p) τ) →
               ⟦ t ⟧C (ctr ρ p) ≡ ⟦ ctrC p t ⟧C ρ
  -- proof omitted
  \end{BVerbatim}
  \caption{Konteksti dubleerimine ja termide kontraheerimine.}
  \label{fig:contraction}
\end{figure}


Mõned erandite monaadi jaoks spetsiifilised, efektide suhtes geneerilised optimisatsioonid on toodud joonisel~\ref{fig:exc.opt1}.
{\tt the-same} näitab, et arvutust {\tt m} ei saa parandada, lisades sellele erandikäsitlejana sama arvutuse.
Erandikäsitlejate assotsiatiivsus on näidatud teisendusega {\tt handler-ass}.
Selle tõestus matkib arvutuse parandusoperaatori assotsiatiivsuse {\tt ⊹-ass} tõestust, milles efektide juhte läbi vaadatakse.

\begin{figure}
  \begin{BVerbatim}
⊹-itself : (e : Exc) → e ⊹ e ≡ e
⊹-itself err = refl
⊹-itself ok = refl
⊹-itself errok = refl

the-same : {e : Exc} {Γ : Ctx} {ρ : ⟪ Γ ⟫X} {σ : VType}
           (m : CTerm Γ (e / σ)) →
           sub-eq (⊹-itself e) (⟦ TRY m WITH m ⟧C ρ) ≡ ⟦ m ⟧C ρ
the-same {err} m = refl
the-same {ok} m = refl
the-same {errok} {ρ = ρ} m with ⟦ m ⟧C ρ
... | just _ = refl
... | nothing = refl


⊹-ass : (e e' e'' : Exc) → e ⊹ (e' ⊹ e'') ≡ (e ⊹ e') ⊹ e''
⊹-ass err e' e'' = refl
⊹-ass ok e' e'' = refl
⊹-ass errok err e'' = refl
⊹-ass errok ok e'' = refl
⊹-ass errok errok err = refl
⊹-ass errok errok ok = refl
⊹-ass errok errok errok = refl

handler-ass : {e₁ e₂ e₃ : Exc} {Γ : Ctx} {ρ : ⟪ Γ ⟫X} {σ : VType}
              (m₁ : CTerm Γ (e₁ / σ)) (m₂ : CTerm Γ (e₂ / σ))
              (m₃ : CTerm Γ (e₃ / σ)) →
              sub-eq (⊹-ass e₁ e₂ e₃)
                     (⟦ TRY m₁ WITH (TRY m₂ WITH m₃) ⟧C ρ)
              ≡ ⟦ TRY (TRY m₁ WITH m₂) WITH m₃ ⟧C ρ
handler-ass {err} m₁ m₂ m₃ = refl
handler-ass {ok} m₁ m₂ m₃ = refl
handler-ass {errok} {err} m₁ m₂ m₃ = refl
handler-ass {errok} {ok} m₁ m₂ m₃ = refl
handler-ass {errok} {errok} {err} m₁ m₂ m₃ = refl
handler-ass {errok} {errok} {ok} {ρ = ρ} m₁ m₂ m₃ with ⟦ m₁ ⟧C ρ
... | just _ = refl
... | nothing = refl
handler-ass {errok} {errok} {errok} {ρ = ρ} m₁ m₂ m₃ with ⟦ m₁ ⟧C ρ
... | just x = refl
... | nothing = refl
  \end{BVerbatim}
  \caption{Erandite monaadi spetsiifilised, efekti suhtes geneerilised teisendused.}
  \label{fig:exc.opt1}
\end{figure}

Mõned erandite monaadi spetsiifilised, efekti-spetsiifilised optimisatsioonid on toodud joonisel~\ref{fig:exc.opt2}.
Iga arvutuse {\tt m}, mille efekt on {\tt err}, saab samaväärselt asendada arvutusega {\tt FAIL σ}.
Samaväärsus {\tt failure m} põhineb asjaolul, et ebaõnnestunud arvutuse semantiline interpretatsioon erandite gradeeritud monaadis on tüüp {\tt ⊤}, milles ongi ainult üks element ja seetõttu on tõestus triviaalne.

Lihtsustus {\tt dead-comp} (jn~\ref{fig:exc.opt2}) näitab, et kui kindlasti õnnestuvat osaarvutust {\tt m} ei pruugita osaarvutuses {\tt n}, siis nende sidumisel pole mõtet ja võib kasutada lihtsalt osaarvutust {\tt n}. Tõestus on eespool antud arvutustermi lõdvenduse {\tt lemma-wkC} rakendus.

Lihtsustus {\tt dup-comp} (jn~\ref{fig:exc.opt2}) võimaldab arvutuse {\tt m} topelt arvutamise asendada ühekordse arvutamisega, kui arvutuse {\tt m} efektiks on {\tt errok}. Tõestuses analüüsitakse kõigepealt arvutuse {\tt n} efekti kuju.
\begin{itemize}
\item Kui see arvutus ebaõnnestub, siis kogu arvutuse interpretatsioon on paratamatult {\tt tt} ja seega tõestus on triviaalne.
\item Kui arvutuse {\tt n} efektiks on {\tt ok}, siis analüüsitakse arvutuse {\tt m} interpretatsiooni. Õnnestunud arvutuse {\tt just x} korral näidatakse ülesande tüüpi nõrgendamise {\tt lemma-wkC} ja {\tt m}-i uuritud interpretatsiooni {\tt eq}-ga ümberkirjutades, et tulemus järeldub lemmast {\tt lemma-ctrC}. Ebaõnnestunud arvutuse korral pole arvutusse {\tt n} ühtegi väärtust siduda ja kogu arvutuse interpretatsiooniks on {\tt nothing}.
\item Kui efektiks on {\tt errok}, siis on tõestus analoogne efekti {\tt ok} juhtumiga, v.a. asjaolu, et arvutuse {\tt n} interpretatsioon on {\tt Maybe} tüüpi.
\end{itemize}

\begin{figure}
  \begin{BVerbatim}
failure : {Γ : Ctx} {σ : VType} (m : CTerm Γ (err / σ)) →
          ⟦ m ⟧C ≡ ⟦ FAIL σ ⟧C
failure m = refl


dead-comp : {Γ : Ctx} {σ σ' : VType} {e : Exc}
            (m : CTerm Γ (ok / σ)) (n : CTerm Γ (e / σ' ) ) →
            (ρ : ⟪ Γ ⟫X) → 
            ⟦ LET m IN (wkC zero n) ⟧C ρ ≡ ⟦ n ⟧C ρ
dead-comp m n ρ = lemma-wkC ρ (⟦ m ⟧C ρ) zero n


errok-seq : (e : Exc) → errok · (errok · e) ≡ errok · e
errok-seq e = sym (ass {errok} {errok} {e})

dup-comp : {e : Exc} {Γ : Ctx} {σ σ' : VType} 
           (m : CTerm Γ (errok / σ)) (n : CTerm (dupX here) (e / σ')) →
           (ρ : ⟪ Γ ⟫X) → 
           sub-eq (errok-seq e)
                  (⟦ LET m IN LET wkC here m IN n ⟧C ρ)
           ≡ ⟦ LET m IN ctrC here n ⟧C ρ
dup-comp {err} m n ρ = refl
dup-comp {ok} m n ρ with ⟦ m ⟧C ρ | inspect ⟦ m ⟧C ρ
... | just x  | [ eq ] rewrite lemma-wkC (x , ρ) here m | eq
                  = cong just (lemma-ctrC (x , ρ) here n)
... | nothing | _ = refl
dup-comp {errok} m n ρ with ⟦ m ⟧C ρ | inspect (⟦ m ⟧C) ρ 
... | just x  | [ eq ] rewrite lemma-wkC (x , ρ) here m | eq
                  = lemma-ctrC (x , ρ) here n
... | nothing | _ = refl
  \end{BVerbatim}
  \caption{Erandite monaadi efekti-spetsiifilised optimisatsioonid.}
  \label{fig:exc.opt2}
\end{figure}

On ka monaadist sõltumatuid optimisatsioone, mille korrektsus järeldub juba üldistest monaadi seadustest ning mis seetõttu kehtivad mitte ainult erandite vaid ka iga teise monaadi jaoks.

\clearpage\vspace*{0pt}

\section{Mittedeterminism}

Selles peatükis vaadeldakse keele laiendust mittedeterministliku valikuga.
Keele efekt seisneb selles, et arvutuse tulemuseks võib olla null või rohkem väärtust.
Staatilise hinnanguna tõkestatakse väärtuste arvu ülevalt.

Baaskeeleks on tüübitud lambdaarvutus koos tõeväärtuste, naturaalarvude ja paaridega.
Kuna baaskeel on sama, mis peatükis~\ref{sec:exc}, siis järgnevates alapeatükkides on toodud välja ainult olulisemad muudatused keele laienduse, tüübituletuse, semantika ja efektianalüüsi osas.


\subsection{Mittedeterministlik keel}

Järgnev BNF esitab mittedeterministliku keele grammatika.
\begin{adjustwidth}{1em}{0pt}
\begin{grammar}\tt
<t> ::= nat | bool | t ● t | t ⇒ $e$ / t \hfill ($e \in$ E)
  
<v> ::= TT | FF | ZZ | SS v | ⟨ v , v ⟩ | FST v | SND v
    \alt VAR $n$ | LAM t c \hfill ($n \in \mathbb N$)
  
<c> ::= VAL v | FAIL t | CHOOSE c c
    \alt IF v THEN c ELSE c | v \$ v | PREC v c c | LET c IN c
\end{grammar}
\end{adjustwidth}

Võrreldes eranditega keelega (ptk~\ref{sec:exc}) on erandikäsitlusega arvutus {\tt TRY_WITH_} asendunud arvutusega {\tt CHOOSE}, mis valib mittedeterministlikult, kumba osaarvutust täita.

Sellise keele rafineeritud ja rafineerimata arvutustermid on toodud joonisel~\ref{fig:nd.cterms}.
Väärtustermid on mõlemal keelel defineeritud samamoodi.
Muutunud on arvutuste efektide tüüp {\tt E}, mis defineeritakse alapeatükis~\ref{ssec:nd.grading}.
Deterministliku rafineeritud arvutustermi {\tt VAL v}, millel on täpselt üks tulemus, efekti hinnanguks on {\tt 1} ja tulemuseta arvutustermi {\tt FAIL} hinnanguks on {\tt 0}.
Tasub märkida, et {\tt 1} on ülehinnang, kuna lubab nii null kui ka täpselt üks tulemust.

\begin{figure}
  \begin{BVerbatim}
data cTerm : Set where
  VAL : vTerm → cTerm
  FAIL : VType → cTerm
  CHOOSE : cTerm → cTerm → cTerm
  IF_THEN_ELSE_ : vTerm → cTerm → cTerm → cTerm
  _$_ : vTerm → vTerm → cTerm
  PREC : vTerm → cTerm → cTerm → cTerm
  LET_IN_ : cTerm → cTerm → cTerm

data CTerm (Γ : Ctx) : CType → Set where
  VAL : {σ : VType} → VTerm Γ σ → CTerm Γ (1 / σ)
  FAIL : (σ : VType) → CTerm Γ (0 / σ)
  CHOOSE : {e e' : E} {σ : VType} → CTerm Γ (e / σ) →
           CTerm Γ (e' / σ) → CTerm Γ ((e ⊹ e') / σ)
  IF_THEN_ELSE_ : {e e' : E} {σ : VType} → VTerm Γ bool →
            CTerm Γ (e / σ) → CTerm Γ (e' / σ) → CTerm Γ ((e ⊔ e') / σ)
  _$_ : {σ : VType} {τ : CType} →
        VTerm Γ (σ ⇒ τ) → VTerm Γ σ → CTerm Γ τ
  PREC : {e e' : E} {σ : VType} → VTerm Γ nat →
         CTerm Γ (e / σ) → CTerm (σ ∷ nat ∷ Γ) (e' / σ) →
         e · e' ⊑ e → CTerm Γ (e / σ)
  LET_IN_ : {e e' : E} {σ σ' : VType} → CTerm Γ (e / σ) →
            CTerm (σ ∷ Γ) (e' / σ') → CTerm Γ (e · e' / σ')
  CCAST : {e e' : E} {σ σ' : VType} → CTerm Γ (e / σ) →
          e / σ ≤C e' / σ' → CTerm Γ (e' / σ')

  \end{BVerbatim}
  \caption{Mittedeterministliku keele arvutustermid.}
  \label{fig:nd.cterms}
\end{figure}


\subsection{Mittedeterminismi gradeering}\label{ssec:nd.grading}

Naturaalarvud {\tt ℕ}, nende korrutamine {\tt _*_} ja ühik {\tt 1} moodustavad monoidi.
Naturaalarvude järjestusseos {\tt _≤_} on refleksiivne {\tt refl≤}, transitiivne {\tt trans≤}. Korrutamine on selle seose suhtes monotoonne {\tt mon*}.
Korrutamise vasakühiku {\tt lu*}, paremühiku {\tt ru*} ja assotsiatiivsuse {\tt ass*} ning monotoonsuse tõestused on toodud töö lähtekoodis.
Sellega rahuldatakse alaptk~\ref{sssec:ordered-monoid} toodud tingimusi ja saab moodustada eeljärjestatud monoidi {\tt ℕ*} (jn~\ref{fig:nd.ordered-monoid}).
\begin{figure}
  \begin{BVerbatim}
ℕ* : OrderedMonoid
ℕ* = record { E = ℕ
            ; _·_ = _*_
            ; i = 1
            ; lu = lu*
            ; ru = ru*
            ; ass = λ {m n o} → ass* {m} {n} {o}
            ; _⊑_ = _≤_
            ; ⊑-refl = refl≤
            ; ⊑-trans = trans≤
            ; mon = mon*
            }
  \end{BVerbatim}
  \caption{Mittedeterminismi eeljärjestatud monoid.}
  \label{fig:nd.ordered-monoid}
\end{figure}


Ülalt tõkestatud pikkusega vektorite tüüp {\tt BVec X} (jn~\ref{fig:nd.bvec}) mingi hulga {\tt X} jaoks on indekseeritud naturaalarvuga {\tt n}, mis näitab vektoris olevate elementide suurimat võimalikku arvu.
Ainsaks konstruktoris on {\tt bv}, mis moodustab täpse pikkusega vektorist ja n-ö ``lõtku'' tõestusest, et selles vektoris ei ole rohkem elemente kui {\tt n}, uue ülalt {\tt n}-iga tõkestatud vektori.
Ülalt tõkestatud vektori päisesse elemendi lisamine {\tt _∷bv_} lisab selle elemendi täpse pikkusega vektori päisesse. Uue lõtku tõestus saadakse vanast kasutades asjaolu, et võrratus jääb kehtima, kui mõlemale poole liita 1.
Vektorite liitmisel {\tt _++bv_} liidetakse täpse pikkusega vektorid omavahel ja elementide lõtku tõestus koostatakse liitmise monotoonsusega kummagi vektori lõtkude tõestusest.

\begin{figure}
  \begin{BVerbatim}
data BVec (X : Set) : (n : ℕ) → Set where
  bv : {m n : ℕ} → Vec X m → m ≤ n → BVec X n

_∷bv_ : {X : Set} {n : ℕ} → X → BVec X n → BVec X (suc n)
x ∷bv (bv xs p) = bv (x ∷ xs) (s≤s p)

_++bv_ : {X : Set} {m n : ℕ} → BVec X m → BVec X n → BVec X (m + n)
bv xs p ++bv bv xs' q = bv (xs ++ xs') (mon+ p q)    
  \end{BVerbatim}
  \caption{Ülalt tõkestatud pikkusega vektor.}
  \label{fig:nd.bvec}
\end{figure}

Eeljärjestatud monoid {\tt ℕ*} ja parametriseeritud tüübikonstruktor {\tt TBV}, mis annab vastava ülalt tõkestatud vektori tüübi, rahuldavad gradeeritud monaadi omadusi (alaptk~\ref{sssec:graded-monad}). Tagastamine {\tt ηBV} koostab üheelemendilise ülalt tõkestatud ja ilma lõtkuta vektori. Sidumine {\tt bindBV} rakendab antud funktsiooni igale vektori elemendile ja liidab saadud ülalt tõkestatud vektorid.
Vastav gradeeritud monaadi definitsioon {\tt NDBV} on toodud joonisel~\ref{fig:nd.graded-monad}.


\begin{figure}
  \begin{BVerbatim}
TBV = λ e X → BVec X e

ηBV : {X : Set} → X → BVec X i
ηBV x = bv (x ∷ []) (s≤s z≤n)

bindBV :  {m n : ℕ} {X Y : Set} →
        (X → BVec Y n) → BVec X m → BVec Y (m · n)
bindBV f (bv [] z≤n) = bv [] z≤n
bindBV f (bv (x ∷ xs) (s≤s p)) = (f x) ++bv bindBV f (bv xs p)

NDBV : GradedMonad
NDBV = record { OM = ℕ*
              ; T = TBV
              ; η = ηBV
              ; bind = λ {e} {e'} → bindBV {e} {e'}
              ; sub = subBV
              ; sub-mon = subBV-mon
              ; sub-refl = subBV-refl
              ; sub-trans = subBV-trans
              ; mlaw1 = blaw1
              ; mlaw2 = blaw2
              ; mlaw3 = blaw3
              }
  \end{BVerbatim}
  \caption{Mittedeterminismi gradeeritud monaad.}
  \label{fig:nd.graded-monad}
\end{figure}

\subsection{Termide tüübituletus ja rafineerimine}

Efektide järjestus võimaldab defineerida alamtüübid.
Kuna see definitsioon on sama, mis eranditega keele puhul (alaptk~\ref{ssec:exc.subtypes}), siis pole seda siinkohal toodud mittedeterministliku keele jaoks.

Osa arvutustermide tüübituletusest on esitatud joonisel~\ref{fig:nd.refine}.
\begin{itemize}
\item {\tt VAL x} on hästi tüübitud, kui väärtusterm {\tt x} on antud kontekstis tüübitud. Arvutuse efekt {\tt 1} tähistab ühte tulemust, mille tüüp {\tt σ} vastab väärtustermile tuletatud tüübile. See on ülehinnang, kuna hinnang {\tt 1} lubab ka 0 tulemust.
\item {\tt FAIL σ} korral on efektiks {\tt 0}, kuna ühtki {\tt σ} tüüpi tulemust ei teki.
\item {\tt CHOOSE t t'} on hästi tüübitud, kui mõlemad arvutustermid {\tt t} ja {\tt t'} on hästi tüübitud. Kogu arvutuse tüüp on määratud vastavalt tuletatud tüüpide {\tt τ} ja {\tt τ'} kombinatsiooniga {\tt τ ⊹C τ'}: efektid liidetakse {\tt _+_}-ga, sest kogu arvutusel on nii palju tulemusi, kui arvutustel {\tt t} ja {\tt t'} kokku. Väärtustüübiks on väärtustüüpide ülemine raja. Kui ülemine raja puudub, siis pole arvutus hästi tüübitud.
\end{itemize}

Rafineeritud arvutustermid on toodud joonisel~\ref{fig:nd.cterms}.
``Toorete'' arvutustermide rafineerimine on esitatud joonisel~\ref{fig:nd.refine}.
\begin{itemize}
\item {\tt VAL t} korral kontrollitakse, et väärtusterm {\tt t} on hästi tüübitud, ja rafineeritud arvutusterm koostatakse vastavast rafineeritud väärtustermist {\tt u}.
\item {\tt FAIL σ} korral näidatakse, et selle arvutustermi tüübituletus õnnestub, ning koostatakse samasugune rafineeritud arvutusterm.
\item {\tt CHOOSE t t'} puhul peavad mõlemad osaarvutused {\tt t} ja {\tt t'} olema hästi tüübitud. Kui neile tuletatud arvutustüüpide väärtustüüpidel on ülemine raja, siis rafineeritud arvutus koostatakse vastavate rafineeringutest {\tt u} ja {\tt u'}, suurendades neid vastavalt ülemise raja tõestusele {\tt p}.
\end{itemize}

\begin{figure}
  \begin{BVerbatim}
infer-ctype : (Γ : Ctx) → cTerm → Maybe CType
infer-ctype Γ (VAL x) with infer-vtype Γ x
... | just σ = just (1 / σ)
... | _      = nothing
infer-ctype Γ (FAIL σ) = just (0 / σ)
infer-ctype Γ (CHOOSE t t') with infer-ctype Γ t | infer-ctype Γ t'
... | just τ | just τ' = τ ⊹C τ'
... | _      | _       = nothing
-- rest of definition omitted

refine-cterm : (Γ : Ctx) (t : cTerm) → refined-cterm Γ t
refine-cterm Γ (VAL t) with infer-vtype Γ t | refine-vterm Γ t
... | just _ | u = VAL u
... | nothing | u = tt 
refine-cterm Γ (FAIL σ) with infer-ctype Γ (FAIL σ)
... | _ = FAIL σ
refine-cterm Γ (CHOOSE t t')
    with infer-ctype Γ t | refine-cterm Γ t |
         infer-ctype Γ t' | refine-cterm Γ t'
... | nothing | _ | _ | _ = tt
... | just _ | _ | nothing | _ = tt
... | just (e / σ) | u | just (e' / σ') | u'
        with σ ⊔V σ' | inspect (_⊔V_ σ) σ'
...     | nothing | _ = tt
...     | just _ | [ p ] =
  CHOOSE (CCAST u (⊔V-subtype p))
         (CCAST u' (⊔V-subtype-sym {σ} p))
-- rest of definition omitted
  \end{BVerbatim}
  \caption{Mittedeterministliku keele tüübituletus ja rafineerimine.}
  \label{fig:nd.refine}
\end{figure}


\subsection{Semantika}

Väärtustermide semantika on antud samamoodi nagu eranditega keeles (alaptk~\ref{ssec:exc.semantics}).
Joonisel~\ref{fig:nd.semantics} on toodud osa arvutustermide semantikast.
\begin{itemize}
\item {\tt VAL x} korral rakendatakse väärtustermi {\tt x} interpretatsioonile ühikut {\tt η} ehk moodustatakse temast lõtkuta vektor pikkusega {\tt 1}.
\item {\tt FAIL σ} korral koostatakse tühi ülalt tõkestatud vektor funktsiooniga {\tt sfail}. Selle vektori elementide tüüp on määratud väärtustüübi {\tt σ} interpretatsiooniga.
\item {\tt CHOOSE t t'} interpretatsioon vastab mittedeterministlikule valikule arvutuste {\tt t} ja {\tt t'} vahel. See on realiseeritud vastavate arvutustermide interpreteerimisel saadud vektorite liitmisega.
\item Ülejäänud arvutustermi konstruktorite semantika on nii nagu eranditega keeles.
\end{itemize}
\begin{figure}
  \begin{BVerbatim}
sfail : {X : Set} → T 0 X
sfail = bv []V z≤n

sor : (e e' : ) {X : Set} → T e X → T e' X → T (e + e') X
sor e e' = _++bv_

⟦_⟧C : {Γ : Ctx} {τ : CType} → CTerm Γ τ → ⟪ Γ ⟫X → ⟪ τ ⟫C
⟦ VAL x ⟧C ρ = η (⟦ x ⟧V ρ)
⟦ FAIL σ ⟧C ρ = sfail {⟪ σ ⟫V}
⟦ CHOOSE {e} {e'} t t' ⟧C ρ = sor e e' (⟦ t ⟧C ρ) (⟦ t' ⟧C ρ)
-- rest of definition omitted
  \end{BVerbatim}
  \caption{Mittedeterministliku keele semantika.}
  \label{fig:nd.semantics}
\end{figure}

\subsection{Optimisatsioonid}

Struktuursed teisendused -- lõdvendamine ja kontraheerimine -- toimivad mittedeterministliku keele puhul analoogselt eranditega keelega. Vastavad tüübisignatuurid on samad, mis alapeatükis~\ref{ssec:exc.optimizations} joonistel~\ref{fig:weakening} ja~\ref{fig:contraction} esitatud.

Näited mittedeterminismi monaadi jaoks spetsiifilistest, kuid efekti-geneerilistest optimisatsioonidest on toodud joonisel~\ref{fig:nd.opt1}.
Lihtsustus {\tt fail-or-m} näitab, et valides mittedeterministlikult arvutuste {\tt FAIL σ} ja {\tt m} vahel on tulemus sama nagu ainult {\tt m} arvutamisel. Kuna konstruktori {\tt CHOOSE} interpretatsioonile vastab osaarvutuste interpreteerimisel saadud tõkestatud vektorite liitmine ja konstruktori {\tt FAIL} interpretatsioon on lihtsalt tühi vektor, siis ekvivalentsi tõestus taandub ülalt tõkestatud vektorite liitmise definitsioonile.

Mittedeterministlik valik on assotsiatiivne. Selline teisendus {\tt choose-ass} on näidatud joonisel~\ref{fig:nd.opt1}. Tõestus tugineb ülalt tõkestatud vektorite liitmise assotsiatiivsusel, mis on tõestatud töö lähtekoodis.

Lihtsustus {\tt fails-earlier} (jn~\ref{fig:nd.opt1}) näitab, et kui siduda ebaõnnestuv arvutus mingi arvutusega {\tt m}, siis tulemus on sama kui kogu arvutus ebaõnnestuks. Sidumise konstruktori {\tt LET_IN_} interpretatsioon seob kõik väärtused esimese osaarvutuse interpretatsioonist, milleks arvutuse {\tt FAIL σ} korral on tühi vektor, teise osaarvutusega. Kuna esimesest osaarvutusest ei tekkinud ühtegi väärtust, siis sidumisel ei saa ka ühtegi väärtust tekkida. Seega on samaväärsus triviaalne.
\begin{figure}
  \begin{BVerbatim}
fail-or-m : {Γ : Ctx} {σ : VType} {e : ℕ} (m : CTerm Γ (e / σ)) →
            (ρ : ⟪ Γ ⟫X) → 
            ⟦ CHOOSE (FAIL σ) m ⟧C ρ ≡ ⟦ m ⟧C ρ
fail-or-m m ρ with ⟦ m ⟧C ρ
... | bv xs p = refl

choose-ass : {e₁ e₂ e₃ : ℕ} {Γ : Ctx} {σ : VType}
             (m₁ : CTerm Γ (e₁ / σ)) (m₂ : CTerm Γ (e₂ / σ))
             (m₃ : CTerm Γ (e₃ / σ)) (ρ : ⟪ Γ ⟫X) →
             sub-eq (+ass {e₁} {e₂} {e₃})
                    (⟦ CHOOSE m₁ (CHOOSE m₂ m₃) ⟧C ρ)
             ≡ ⟦ CHOOSE (CHOOSE m₁ m₂) m₃ ⟧C ρ
choose-ass m₁ m₂ m₃ ρ with ⟦ m₁ ⟧C ρ | ⟦ m₂ ⟧C ρ | ⟦ m₃ ⟧C ρ
... | bv₁ | bv₂ | bv₃ = lemma-ass++ bv₁ bv₂ bv₃

fails-earlier : {e : ℕ} {Γ : Ctx} {ρ : ⟪ Γ ⟫X} {σ σ' : VType}
                (m : CTerm (σ ∷l Γ) (e / σ')) →
                ⟦ LET FAIL σ IN m ⟧C ρ ≡ ⟦ FAIL σ' ⟧C ρ
fails-earlier m = refl
  \end{BVerbatim}
  \caption{Mittedeterminismi spetsiifilised, efekti suhtes geneerilised teisendused.}
  \label{fig:nd.opt1}
\end{figure}

Joonisel~\ref{fig:nd.opt2} on toodud mõned mittedeterminismi efekti-spetsiifilised teisendused. Lihtsustus {\tt failure} näitab, et iga arvutuse {\tt m}, mille arvutuse tulemusena ei teki mitte ühtegi väärtust (teisisõnu: arvutusel on ülimalt {\tt 0} väärtust), võib samaväärsena asendada arvutuse ebaõnnestumise konstruktsiooniga {\tt FAIL}. Kuna arvutustermi {\tt m} interpretatsioon antud konteksti interpretatsioonis {\tt ρ} on tühi ülalt {\tt 0}-ga tõkestatud vektor, siis tõestus on triviaalne.

Samaväärsus {\tt dup-comp} (jn~\ref{fig:nd.opt2}) näitab, et iga arvutust {\tt m}, mille efekt on ülimalt {\tt 1}, pole vaja topelt arvutada. Põhjendus on järgnev: kui {\tt m} tulemuseks on täpselt üks väärtus, siis {\tt LET_IN_} sidumisel {\tt m}-iga ei teki väärtuseid juurde ja võib kohe selle väärtuse siduda {\tt n}-iga; kui {\tt m} arvutuse tulemusel ühtegi väärtust ei teki, siis pole ka järgnevatesse arvutustesse midagi siduda. Tõestus on antud töö lähtekoodis.
\begin{figure}
  \begin{BVerbatim}
failure : {Γ : Ctx} {σ : VType} (m : CTerm Γ (0 / σ)) →
          (ρ : ⟪ Γ ⟫X) → 
          ⟦ m ⟧C ρ ≡ ⟦ FAIL σ ⟧C ρ
failure m ρ with ⟦ m ⟧C ρ
... | bv [] z≤n = refl

dup-comp : {e : ℕ} {Γ : Ctx} {σ σ' : VType} 
           (m : CTerm Γ (1 / σ)) (n : CTerm (dupX here) (e / σ')) →
           (ρ : ⟪ Γ ⟫X) → 
           sub-eq (errok-seq e)
                  (⟦ LET m IN LET wkC here m IN n ⟧C ρ)
           ≡ ⟦ LET m IN ctrC here n ⟧C ρ
-- proof omitted
  \end{BVerbatim}
  \caption{Mittedeterminismi monaadi efekti-spetsiifilised optimisatsioonid.}
  \label{fig:nd.opt2}
\end{figure}

Antud töös on mittedeterministliku keele semantika antud ülalt tõkestatud vektoriga,
kuid seda võib teha ka multihulkadel, kus pole tulemuste järjekord oluline.
Lisada võib ka nt alumised tõkked, st hinnata listi või multihulka intervalliga.
Minnes pisut ebatäpsemaks, võib multihulgad asendada ka hulkadega (nt {\tt 0} -- ebaõnnestumine, {\tt 1} -- deterministlik, {\tt 01} -- pooldeterministlik, {\tt 1+} -- mitmikdeterministlik, {\tt N} -- mittedeterministlik), siis saab tõestada surnud arvutuse eemaldamise (\emph{dead computation}) ja arvutuse väljatõstmise (\emph{pure lambda hoist}) lihtsustused \cite{Benton2016}.

\clearpage\vspace*{0pt}


\section{Kokkuvõte}
%Kokkuvõttes esitab autor töö põhieesmärgi, vastused sissejuhatuses püstitatud
%küsimustele, toob välja töö olulisemad tulemused ja järeldused.

Käesoleva töö eesmärgiks oli realiseerida sõltuvate tüüpidega programmeerimiskeeles Agda efektianalüüside ja neil põhinevate programmiteisenduste raamistu.

Esitati erandeid toetav näitekeel.
Seejärel defineeriti erandite efektide hindamine, tuues sisse gradeeritud monaadi mõiste.
Gradeeringu abil määrati alamtüübid ja -efektid, millele tugines keele rafineerimine.
Keele semantika defineeriti juba rafineeritud keelele.
Töö käigus valmisid programmiteisendused, mh ``surnud'' arvutuse ja korduva arvutuse eemaldamise optimisatsioonid.
Ühtlasi näidati, et need teisendused on korrektsed.

Töö teises pooles kasutati mittedeterminismi toetavat näitekeelt.
Keele semantika andmiseks loodi ülalt tõkestatud vektori andmestruktuur.
Sellega koos anti naturaalarvude korrutamise jaoks gradeeritud monaadi instants.
Defineeriti termide tüübituletus ja keele rafineerimine.
Esitati ebaõnnestunud arvutuse ja korduva arvutuse eemaldamise optimisatsioonid ning näidati selliste teisenduste korrektsust.

Sertifitseeritud programmeerimine on mahukas ettevõtmine, kuna arutelu isegi intuitiivselt õige aritmeetika üle võib osutuda ajakulukaks.
Kõigele vaatamata õnnestus efektianalüüside ja programmiteisenduste raamistu realiseerimine Agdas andmetüüpe toetavatele keeltele.

\clearpage\vspace*{0pt}

\renewcommand{\baselinestretch}{1.15}
\small
\bibliographystyle{unsrt}
\bibliography{thesis}
\end{document}
